#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

const int GROUP_SIZE = 16;

#include "sampling.h"

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(binding = 0, rgba32f) uniform image2D inImage0;
layout(binding = 1, rgba32f) uniform image2D inImage1;
layout(binding = 2, rg32f) uniform image2D inImage2;
layout(binding = 3) uniform accelerationStructureEXT topLevelAS;
layout(binding = 4) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};
layout(binding = 5, r32f) uniform image2D outImage;

//----------------------------------------------------------------------------
// Tracing a ray and returning the weight based on the distance of the hit
//
float TraceRay(in rayQueryEXT rayQuery, in vec3 origin, in vec3 direction)
{
	uint flags = gl_RayFlagsNoneEXT;
	if(rtao_distance_based == 0)
		flags = gl_RayFlagsTerminateOnFirstHitEXT;

	rayQueryInitializeEXT(rayQuery, topLevelAS, flags, 0xFF, origin, 0.0f, direction, rtao_radius);

	// Start traversal: return false if traversal is complete
	while(rayQueryProceedEXT(rayQuery))
	{
	}

	// Returns type of committed (true) intersection
	if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
	{
		// Got an intersection == Shadow
		if(rtao_distance_based == 0)
			return 1;
		float length = 1 - (rayQueryGetIntersectionTEXT(rayQuery, true) / rtao_radius);
		return length;  // * length;
	}

	return 0;
}

void main()
{
	float occlusion = 0.0;

	ivec2 size = imageSize(outImage);
	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y)
		return;

	// Initialize the random number
	uint seed = TEA(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, frame_number);

	// Retrieving position and normal
	vec4 gBuffer0 = imageLoad(inImage0, ivec2(gl_GlobalInvocationID.xy));
	vec4 gBuffer1 = imageLoad(inImage1, ivec2(gl_GlobalInvocationID.xy));

	vec2 velocity = imageLoad(inImage2, ivec2(gl_GlobalInvocationID.xy)).rg;

	// Shooting rays only if a fragment was rendered
	if(gBuffer0 != vec4(0))
	{
		vec3 normal = gBuffer0.xyz;
		vec3 origin = gBuffer1.xyz;
		vec3 direction;

		// Move origin slightly away from the surface to avoid self-occlusion
		origin = OffsetRay(origin, normal);

		// Finding the basis (tangent and bitangent) from the normal
		vec3 n, tangent, bitangent;
		ComputeDefaultBasis(normal, tangent, bitangent);

		// Sampling hemiphere n-time
		for(int i = 0; i < rtao_samples; i++)
		{
			// Cosine sampling
			float r1        = RND(seed);
			float r2        = RND(seed);
			float sq        = sqrt(1.0 - r2);
			float phi       = 2 * M_PI * r1;
			vec3  direction = vec3(cos(phi) * sq, sin(phi) * sq, sqrt(r2));
			direction       = direction.x * tangent + direction.y * bitangent + direction.z * normal;
			// Initializes a ray query object but does not start traversal
			rayQueryEXT rayQuery;

			occlusion += TraceRay(rayQuery, origin, direction);
		}

		// Computing occlusion
		occlusion = 1 - (occlusion / rtao_samples);
		occlusion = pow(clamp(occlusion, 0, 1), rtao_power);
	}

	// Writting out the AO
	if(frame_number == 0)
	{
		imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(occlusion));
	}
	else
	{
		// Accumulating over time
		float old_ao     = imageLoad(outImage, ivec2(gl_GlobalInvocationID.xy)).x;
		float new_result = mix(old_ao, occlusion, 1.0f / float(frame_number + 1));
		imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(new_result));
	}

	// imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(velocity, 0.0, 0.0));
}