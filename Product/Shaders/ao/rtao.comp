#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

const int GROUP_SIZE = 16;

#include "sampling.h"

#define BINDING_GBUFFER_NORMAL 0
#define BINDING_GBUFFER_POSITION 1
#define BINDING_VELOCITY 2
#define BINDING_AS 3
#define BDINING_UNIFORM 4
#define BINDING_PREV 5
#define BINDING_OUT 6

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(binding = BINDING_GBUFFER_NORMAL, rgba32f) uniform image2D inImage0;
layout(binding = BINDING_GBUFFER_POSITION, rgba32f) uniform image2D inImage1;
layout(binding = BINDING_VELOCITY, rg32f) uniform image2D inImage2;
layout(binding = BINDING_AS) uniform accelerationStructureEXT topLevelAS;
layout(binding = BDINING_UNIFORM) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};
layout(binding = BINDING_PREV, rg32f) uniform image2D prevImage;
layout(binding = BINDING_OUT, rg32f) uniform image2D outImage;

//----------------------------------------------------------------------------
// Tracing a ray and returning the weight based on the distance of the hit
//
float TraceRay(in rayQueryEXT rayQuery, in vec3 origin, in vec3 direction)
{
	uint flags = gl_RayFlagsNoneEXT;
	if(rtao_distance_based == 0)
		flags = gl_RayFlagsTerminateOnFirstHitEXT;

	rayQueryInitializeEXT(rayQuery, topLevelAS, flags, 0xFF, origin, 0.0f, direction, rtao_radius);

	// Start traversal: return false if traversal is complete
	while(rayQueryProceedEXT(rayQuery))
	{
	}

	// Returns type of committed (true) intersection
	if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
	{
		// Got an intersection == Shadow
		if(rtao_distance_based == 0)
			return 1;
		float length = 1 - (rayQueryGetIntersectionTEXT(rayQuery, true) / rtao_radius);
		return length;
	}

	return 0;
}

vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 prevSample, vec3 avg)
{
#ifdef CLIP_TO_CENTER
	// note: only clips towards aabb center (but fast!)
	vec3 p_clip = 0.5 * (aabbMax + aabbMin);
	vec3 e_clip = 0.5 * (aabbMax - aabbMin);

	vec3 v_clip = prevSample - p_clip;
	vec3 v_unit = v_clip.xyz / e_clip;
	vec3 a_unit = abs(v_unit);
	float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

	if (ma_unit > 1.0)
		return p_clip + v_clip / ma_unit;
	else
		return prevSample;// point inside aabb
#else
	vec3 r = prevSample - avg;
	vec3 rmax = aabbMax - avg.xyz;
	vec3 rmin = aabbMin - avg.xyz;

	const float eps = 0.000001f;

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return avg + r;
#endif
}

const ivec2 offset[4] = 
{
	ivec2(-1, -1), ivec2(-1, 1),
	//ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0),
	ivec2(1, -1), ivec2(1, 1)
};

bool IsWithinBounds(ivec2 pos, ivec2 size)
{
	return pos.x >= 0 && pos.y >= 0 && pos.x < size.x && pos.y < size.y;
}

// https://zhuanlan.zhihu.com/p/64993622
float FetchPrevResult(ivec2 prevSamplePos, ivec2 curSamplePos, ivec2 outSize)
{
	vec3 prevSample = imageLoad(prevImage, prevSamplePos).rgb;
	vec3 curSample = imageLoad(prevImage, curSamplePos).rgb;
	vec3 sumSample = curSample;
	vec3 squareSumSample = curSample * curSample;

	float N = 1;
	for(int i = 0; i < 4; ++i)
	{
		ivec2 samplePos = curSamplePos + offset[i];
		if(IsWithinBounds(samplePos, outSize))
		{
			vec3 result = imageLoad(prevImage, samplePos).rgb;
			sumSample += result;
			squareSumSample += result * result;
			++N;
		}
	}
	if(N > 1)
	{
		// Variance clip.
		const float VarianceClipGamma = 1.0;
		vec3 mu = sumSample / N;
		vec3 sigma = sqrt(abs(squareSumSample / N - mu * mu));
		vec3 minc = mu - VarianceClipGamma * sigma;
		vec3 maxc = mu + VarianceClipGamma * sigma;

		prevSample.rgb = ClipAABB(minc.rgb, maxc.rgb, prevSample.rgb, mu.rgb);
		return prevSample.r;
	}
	else
	{
		return curSample.r;
	}
}

vec2 FetchMotionVector(ivec2 curSampleGPos, ivec2 inSize, ivec2 outSize)
{
	ivec2 minSamplePos = curSampleGPos;
	float minDepth = imageLoad(inImage0, curSampleGPos).a;

	for(int i = 0; i < 4; ++i)
	{
		ivec2 samplePos = curSampleGPos + offset[i];
		if(IsWithinBounds(samplePos, inSize))
		{
			float result = imageLoad(inImage0, samplePos).a;
			if(result < minDepth)
			{
				minDepth = result;
				minSamplePos = samplePos;
			}
		}
	}

	vec2 motion = imageLoad(inImage2, minSamplePos).rg;
	motion = (motion * vec2(outSize)) / vec2(outSize);
	return motion;
}

void main()
{
	float occlusion = 0.0;

	ivec2 inSize = imageSize(inImage0);
	ivec2 outSize = imageSize(outImage);

	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= outSize.x || gl_GlobalInvocationID.y >= outSize.y)
	{
		return;
	}

	// Initialize the random number
	uint seed = TEA(outSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, frame_number);

	vec2 curTexPos = (gl_GlobalInvocationID.xy + 0.5) / vec2(outSize);
	ivec2 curSamplePos = ivec2(round(curTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 curSampleGPos = ivec2(round(curTexPos * vec2(inSize) - vec2(0.5)));
	vec2 motion = FetchMotionVector(curSampleGPos, inSize, outSize);

	vec2 preTexPos = curTexPos - motion;
	ivec2 prevSamplePos = ivec2(round(preTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 prevSampleGPos = ivec2(round(preTexPos * vec2(inSize) - vec2(0.5)));
	float prev_result = 0.0;

	vec4 prev_normal_depth = imageLoad(inImage0, curSampleGPos);
	vec4 cur_normal_depth = imageLoad(inImage0, prevSampleGPos);

	if(dot(motion, motion) < 1e-4
	&& dot(cur_normal_depth.rgb, prev_normal_depth.rgb) > 0.1
	&& abs(cur_normal_depth.a - prev_normal_depth.a) < 0.5)
	{
		prev_result = FetchPrevResult(prevSamplePos, curSamplePos, outSize).r;
	}

	vec3 normal = imageLoad(inImage0, curSampleGPos).rgb;
	if(normal != vec3(0))
	{
		vec3 origin = imageLoad(inImage1, curSampleGPos).rgb;
		vec3 direction;

		// Move origin slightly away from the surface to avoid self-occlusion
		origin = OffsetRay(origin, normal);

		// Finding the basis (tangent and bitangent) from the normal
		vec3 n, tangent, bitangent;
		ComputeDefaultBasis(normal, tangent, bitangent);

		// Sampling hemiphere n-time
		for(int i = 0; i < rtao_samples; i++)
		{
			// Cosine sampling
			float r1        = RND(seed);
			float r2        = RND(seed);
			float sq        = sqrt(1.0 - r2);
			float phi       = 2 * M_PI * r1;
			vec3  direction = vec3(cos(phi) * sq, sin(phi) * sq, sqrt(r2));
			direction       = direction.x * tangent + direction.y * bitangent + direction.z * normal;
			// Initializes a ray query object but does not start traversal
			rayQueryEXT rayQuery;

			occlusion += TraceRay(rayQuery, origin, direction);
		}

		// Computing occlusion
		occlusion = 1 - (occlusion / rtao_samples);
		occlusion = pow(clamp(occlusion, 0, 1), rtao_power);
	}
	else
	{
		occlusion = 1.0;
	}

	// Accumulating over time
	if(prev_result > 0.0)
	{
		float old_ao     = prev_result;
		float new_result = mix(old_ao, occlusion, 0.02);
		imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(new_result));
	}
	else
	{
		imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(occlusion));
	}

	// imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), sign(imageLoad(inImage2, curSampleGPos)));
	// imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), prev_normal_depth);
}