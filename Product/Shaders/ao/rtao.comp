#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

const int GROUP_SIZE = 32;

#include "sampling.h"
#include "rtao_define.h"

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(binding = BINDING_GBUFFER_NORMAL, rgba32f) uniform image2D normalImage;
layout(binding = BINDING_GBUFFER_POSITION, rgba32f) uniform image2D positionImage;
layout(binding = BINDING_AS) uniform accelerationStructureEXT topLevelAS;
layout(binding = BDINING_UNIFORM) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};
layout(binding = BINDING_CUR, rg16f) uniform image2D outImage;
layout(binding = BINDING_LOCAL_MEAN_VARIANCE_OUTPUT, rg16f) uniform image2D meanOutputImage;

//----------------------------------------------------------------------------
// Tracing a ray and returning the weight based on the distance of the hit
//
float TraceRay(in rayQueryEXT rayQuery, in vec3 origin, in vec3 direction, in out float dis)
{
	uint flags = gl_RayFlagsNoneEXT;
	if(rtao_distance_based == 0)
		flags = gl_RayFlagsTerminateOnFirstHitEXT;

	rayQueryInitializeEXT(rayQuery, topLevelAS, flags, 0xFF, origin, 0.0f, direction, rtao_radius);

	// Start traversal: return false if traversal is complete
	while(rayQueryProceedEXT(rayQuery))
	{
	}

	dis = rtao_radius + 0.001;

	// Returns type of committed (true) intersection
	if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
	{
		dis = rayQueryGetIntersectionTEXT(rayQuery, true);
		// Got an intersection == Shadow
		if(rtao_distance_based == 0)
			return 1;
		else
			return 1 - (dis / rtao_radius);
	}

	return 0;
}

void main()
{
	float occlusion = 0.0;

	ivec2 inSize = imageSize(normalImage);
	ivec2 outSize = imageSize(outImage);

	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= outSize.x || gl_GlobalInvocationID.y >= outSize.y) return;

	bool pixelSkip = false; //mod(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y, 2) == mod(frame_number, 2);
	if(pixelSkip)
	{
		return;
	}

	vec2 curTexPos = (gl_GlobalInvocationID.xy + 0.5) / vec2(outSize);
	ivec2 curSamplePos = ivec2(round(curTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 curSampleGPos = ivec2(round(curTexPos * vec2(inSize) - vec2(0.5)));

	vec3 normal = imageLoad(normalImage, curSampleGPos).rgb;
	float hitDistance = 0.0;
	if(normal != vec3(0))
	{
		// Initialize the random number
		uint seed = TEA(outSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, frame_number);
		vec3 origin = imageLoad(positionImage, curSampleGPos).rgb;
		vec3 direction;

		// Move origin slightly away from the surface to avoid self-occlusion
		origin = OffsetRay(origin, normal);

		// Finding the basis (tangent and bitangent) from the normal
		vec3 n, tangent, bitangent;
		ComputeDefaultBasis(normal, tangent, bitangent);

		// Sampling hemiphere n-time
		for(int i = 0; i < rtao_samples; i++)
		{
			// Cosine sampling
			float r1        = RND(seed);
			float r2        = RND(seed);
			float sq        = sqrt(1.0 - r2);
			float phi       = 2 * M_PI * r1;
			vec3  direction = vec3(cos(phi) * sq, sin(phi) * sq, sqrt(r2));
			direction       = direction.x * tangent + direction.y * bitangent + direction.z * normal;
			// Initializes a ray query object but does not start traversal
			rayQueryEXT rayQuery;

			float dis = 0.0;
			occlusion += TraceRay(rayQuery, origin, direction, dis);
			hitDistance += dis;
		}

		// Computing occlusion
		occlusion = 1 - (occlusion / rtao_samples);
		occlusion = pow(clamp(occlusion, 0, 1), rtao_power);
	}
	else
	{
		hitDistance = rtao_radius + 0.001;
		occlusion = 1.0;
	}

	imageStore(outImage, curSamplePos, vec4(occlusion, hitDistance, 0, 0));
	imageStore(meanOutputImage, curSamplePos, vec4(occlusion, occlusion * occlusion, 0, 0));
}