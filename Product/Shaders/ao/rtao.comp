#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

const int GROUP_SIZE = 16;

#include "sampling.h"

#define BINDING_GBUFFER_NORMAL 0
#define BINDING_GBUFFER_POSITION 1
#define BINDING_VELOCITY 2
#define BINDING_AS 3
#define BDINING_UNIFORM 4
#define BINDING_PREV 5
#define BINDING_OUT 6

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(binding = BINDING_GBUFFER_NORMAL, rgba32f) uniform image2D inImage0;
layout(binding = BINDING_GBUFFER_POSITION, rgba32f) uniform image2D inImage1;
layout(binding = BINDING_VELOCITY, rg32f) uniform image2D inImage2;
layout(binding = BINDING_AS) uniform accelerationStructureEXT topLevelAS;
layout(binding = BDINING_UNIFORM) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};
layout(binding = BINDING_PREV, rg32f) uniform image2D prevImage;
layout(binding = BINDING_OUT, rg32f) uniform image2D outImage;

//----------------------------------------------------------------------------
// Tracing a ray and returning the weight based on the distance of the hit
//
float TraceRay(in rayQueryEXT rayQuery, in vec3 origin, in vec3 direction)
{
	uint flags = gl_RayFlagsNoneEXT;
	if(rtao_distance_based == 0)
		flags = gl_RayFlagsTerminateOnFirstHitEXT;

	rayQueryInitializeEXT(rayQuery, topLevelAS, flags, 0xFF, origin, 0.0f, direction, rtao_radius);

	// Start traversal: return false if traversal is complete
	while(rayQueryProceedEXT(rayQuery))
	{
	}

	// Returns type of committed (true) intersection
	if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
	{
		// Got an intersection == Shadow
		if(rtao_distance_based == 0)
			return 1;
		float length = 1 - (rayQueryGetIntersectionTEXT(rayQuery, true) / rtao_radius);
		return length;
	}

	return 0;
}

vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 prevSample, vec3 avg)
{
#ifdef CLIP_TO_CENTER
	// note: only clips towards aabb center (but fast!)
	vec3 p_clip = 0.5 * (aabbMax + aabbMin);
	vec3 e_clip = 0.5 * (aabbMax - aabbMin);

	vec3 v_clip = prevSample - p_clip;
	vec3 v_unit = v_clip.xyz / e_clip;
	vec3 a_unit = abs(v_unit);
	float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

	if (ma_unit > 1.0)
		return p_clip + v_clip / ma_unit;
	else
		return prevSample;// point inside aabb
#else
	vec3 r = prevSample - avg;
	vec3 rmax = aabbMax - avg.xyz;
	vec3 rmin = aabbMin - avg.xyz;

	const float eps = 0.000001f;

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return avg + r;
#endif
}

// #define SMALL_OFFSET

#ifdef SMALL_OFFSET
#define OFFSET_ARRAY_SIZE 4
#else
#define OFFSET_ARRAY_SIZE 8
#endif

const ivec2 offset[OFFSET_ARRAY_SIZE] = 
{
	ivec2(-1, -1), ivec2(-1, 1),
#ifndef SMALL_OFFSET
	ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0),
#endif
	ivec2(1, -1), ivec2(1, 1)
};

bool IsWithinBounds(ivec2 pos, ivec2 size)
{
	return pos.x >= 0 && pos.y >= 0 && pos.x < size.x && pos.y < size.y;
}

// https://zhuanlan.zhihu.com/p/64993622
float FetchPrevResult(ivec2 prevSamplePos, ivec2 curSamplePos, ivec2 outSize)
{
	vec3 prevSample = imageLoad(prevImage, prevSamplePos).rrr;
	vec3 curSample = imageLoad(prevImage, curSamplePos).rrr;
	vec3 sumSample = curSample;
	vec3 squareSumSample = curSample * curSample;

	float N = 1;
	for(int i = 0; i < OFFSET_ARRAY_SIZE; ++i)
	{
		ivec2 samplePos = curSamplePos + offset[i];
		if(IsWithinBounds(samplePos, outSize))
		{
			vec3 result = imageLoad(prevImage, samplePos).rrr;
			sumSample += result;
			squareSumSample += result * result;
			++N;
		}
	}
	if(N > 1)
	{
		// Variance clip.
		const float VarianceClipGamma = 1.0;
		vec3 mu = sumSample / N;
		vec3 sigma = sqrt(abs(squareSumSample / N - mu * mu));
		vec3 minc = mu - VarianceClipGamma * sigma;
		vec3 maxc = mu + VarianceClipGamma * sigma;

		prevSample.rgb = ClipAABB(minc.rgb, maxc.rgb, prevSample.rgb, mu.rgb);
		return prevSample.r;
	}
	else
	{
		return curSample.r;
	}
}

vec2 FetchMotionVector(ivec2 curSampleGPos, ivec2 inSize, ivec2 outSize)
{
	ivec2 minSamplePos = curSampleGPos;
	float minDepth = imageLoad(inImage0, curSampleGPos).a;

	for(int i = 0; i < OFFSET_ARRAY_SIZE; ++i)
	{
		ivec2 samplePos = curSampleGPos + offset[i];
		if(IsWithinBounds(samplePos, inSize))
		{
			float result = imageLoad(inImage0, samplePos).a;
			if(result < minDepth)
			{
				minDepth = result;
				minSamplePos = samplePos;
			}
		}
	}

	vec2 motion = imageLoad(inImage2, minSamplePos).rg;
	motion = (motion * vec2(outSize)) / vec2(outSize);
	return motion;
}

vec2 DDXYDepth(ivec2 curSampleGPos, ivec2 inSize)
{
	float depth = imageLoad(inImage0, curSampleGPos).a;

	ivec2 xBiasSampleGPos = curSampleGPos + ivec2(1, 0);
	float xBiasDepth = IsWithinBounds(xBiasSampleGPos, inSize) ? imageLoad(inImage0, xBiasSampleGPos).a : depth;

	ivec2 yBiasSampleGPos = curSampleGPos + ivec2(0, 1);
	float yBiasDepth = IsWithinBounds(yBiasSampleGPos, inSize) ? imageLoad(inImage0, yBiasSampleGPos).a : depth;

	return vec2(xBiasDepth - depth, yBiasDepth - depth);
}

void main()
{
	float occlusion = 0.0;

	ivec2 inSize = imageSize(inImage0);
	ivec2 outSize = imageSize(outImage);

	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= outSize.x || gl_GlobalInvocationID.y >= outSize.y) return;

	vec2 curTexPos = (gl_GlobalInvocationID.xy + 0.5) / vec2(outSize);
	ivec2 curSamplePos = ivec2(round(curTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 curSampleGPos = ivec2(round(curTexPos * vec2(inSize) - vec2(0.5)));
	vec2 motion = FetchMotionVector(curSampleGPos, inSize, outSize);

	vec2 preTexPos = curTexPos - motion;
	ivec2 prevSamplePos = ivec2(round(preTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 prevSampleGPos = ivec2(round(preTexPos * vec2(inSize) - vec2(0.5)));

	vec4 prev_normal_depth = imageLoad(inImage0, curSampleGPos);
	vec4 cur_normal_depth = imageLoad(inImage0, prevSampleGPos);

	uint tspp = floatBitsToUint(imageLoad(outImage, prevSamplePos).g);
	float prev = 0.0;
	float weight = 0.0;

	if(dot(motion, motion) < 1e-4)
	{
		prev = FetchPrevResult(prevSamplePos, curSamplePos, outSize).r;
		float normalWeight = clamp(dot(cur_normal_depth.rgb, prev_normal_depth.rgb), 0.0, 1.0);
		normalWeight = pow(normalWeight, 1.0);

		vec2 ddxyDepth = DDXYDepth(curSampleGPos, inSize);
		float precisionNum = 1e-10;
		float depthThreshold = dot(vec2(1.0), abs(ddxyDepth));
		float depthTolerance = 1e5 * depthThreshold + precisionNum;

		float depthWeight = min(depthTolerance / (abs(prev_normal_depth.a - cur_normal_depth.a) + precisionNum), 1);
		// FIXME: Why Jitter happens when precisionNum is 0
		depthWeight = max(depthWeight, 0.0);
		depthWeight = pow(depthWeight, 1.0);

		weight = normalWeight * depthWeight;
	}

	if(weight < 1e-4)
	{
		tspp = 0;
	}
	tspp = uint(round(float(tspp) * weight));

	// if(tspp >= max_samples && dot(motion, motion) < 1e-4) return;

	vec3 normal = imageLoad(inImage0, curSampleGPos).rgb;
	if(normal != vec3(0))
	{
		// Initialize the random number
		uint seed = TEA(outSize.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, frame_number);

		vec3 origin = imageLoad(inImage1, curSampleGPos).rgb;
		vec3 direction;

		// Move origin slightly away from the surface to avoid self-occlusion
		origin = OffsetRay(origin, normal);

		// Finding the basis (tangent and bitangent) from the normal
		vec3 n, tangent, bitangent;
		ComputeDefaultBasis(normal, tangent, bitangent);

		// Sampling hemiphere n-time
		for(int i = 0; i < rtao_samples; i++)
		{
			// Cosine sampling
			float r1        = RND(seed);
			float r2        = RND(seed);
			float sq        = sqrt(1.0 - r2);
			float phi       = 2 * M_PI * r1;
			vec3  direction = vec3(cos(phi) * sq, sin(phi) * sq, sqrt(r2));
			direction       = direction.x * tangent + direction.y * bitangent + direction.z * normal;
			// Initializes a ray query object but does not start traversal
			rayQueryEXT rayQuery;

			occlusion += TraceRay(rayQuery, origin, direction);
		}

		// Computing occlusion
		occlusion = 1 - (occlusion / rtao_samples);
		occlusion = pow(clamp(occlusion, 0, 1), rtao_power);
	}
	else
	{
		occlusion = 1.0;
	}

	if(tspp == 0)
	{
		imageStore(outImage, curSamplePos, vec4(occlusion, uintBitsToFloat(tspp + 1), 0, 0));
	}
	else
	{
		const float maxBlend = 0.2;
		const float minBlend = 0.00002;
		float blend = max(minBlend, min(1.0 / (tspp + 1), maxBlend));
		blend = mix(blend, maxBlend, clamp(length(motion * vec2(outSize) * 1.0), 0.0, 1.0));
		blend = mix(blend, 1.0, 1.0 - weight);
		occlusion = mix(prev, occlusion, blend);
		imageStore(outImage, curSamplePos, vec4(occlusion, uintBitsToFloat(tspp + 1), 0, 0));
	}

	// imageStore(outImage, curSamplePos, vec4(100000000 * DDXYDepth(curSampleGPos, inSize), 0.0, 0.0));
}