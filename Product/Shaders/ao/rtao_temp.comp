const int GROUP_SIZE = 32;

#include "sampling.h"
#include "rtao_define.h"

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(binding = BINDING_GBUFFER_NORMAL, rgba32f) uniform image2D normalImage;
layout(binding = BINDING_GBUFFER_POSITION, rgba32f) uniform image2D positionImage;
layout(binding = BINDING_PREV_NORMAL_DEPTH, rgba32f) uniform image2D prevNormalDepthImage;
layout(binding = BINDING_CUR_NORMAL_DEPTH, rgba32f) uniform image2D curNormalDepthImage;
layout(binding = BINDING_VELOCITY, rg32f) uniform image2D motionImage;
layout(binding = BDINING_UNIFORM) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};

layout(binding = BINDING_TEMPORAL_SQAREDMEAN_VARIANCE, rg16f) uniform image2D sqaredMeanVarianceImage;
layout(binding = BINDING_PREV, rg32f) uniform image2D prevImage;
layout(binding = BINDING_CUR, rg16f) uniform image2D curImage;
layout(binding = BINDING_LOCAL_MEAN_VARIANCE_INPUT, rg16f) uniform image2D meanInputImage;
layout(binding = BINDING_FINAL, rg32f) uniform image2D outImage;

#define PREFER_CLIP_THAN_CLAMP
#define CLIP_TO_CENTER

vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 prevSample, vec3 avg)
{
#ifdef PREFER_CLIP_THAN_CLAMP
#ifdef CLIP_TO_CENTER
	// note: only clips towards aabb center (but fast!)
	vec3 p_clip = 0.5 * (aabbMax + aabbMin);
	vec3 e_clip = 0.5 * (aabbMax - aabbMin);

	vec3 v_clip = prevSample - p_clip;
	vec3 v_unit = v_clip.xyz / e_clip;
	vec3 a_unit = abs(v_unit);
	float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

	if (ma_unit > 1.0)
		return p_clip + v_clip / ma_unit;
	else
		return prevSample;// point inside aabb
#else // CLIP_TO_CENTER
	vec3 r = prevSample - avg;
	vec3 rmax = aabbMax - avg.xyz;
	vec3 rmin = aabbMin - avg.xyz;

	const float eps = 0.000001f;

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return avg + r;
#endif
#else // PREFER_CLIP_THAN_CLAMP
	return clamp(prevSample, aabbMin, aabbMax);
#endif
}

// #define SMALL_OFFSET

#ifdef SMALL_OFFSET
#define OFFSET_ARRAY_SIZE 4
#else
#define OFFSET_ARRAY_SIZE 8
#endif

const ivec2 offset[OFFSET_ARRAY_SIZE] = 
{
	ivec2(-1, -1), ivec2(-1, 1),
#ifndef SMALL_OFFSET
	ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0),
#endif
	ivec2(1, -1), ivec2(1, 1)
};

float ClampPrevResult(float unclamp, vec2 localMeanVariance)
{
	const vec3 VarianceClipGamma = vec3(1.0);
	float sigma = sqrt(localMeanVariance.g);
	vec3 prevSample = vec3(unclamp);
	vec3 mu = vec3(localMeanVariance.r);
	vec3 minc = mu - VarianceClipGamma * sigma;
	vec3 maxc = mu + VarianceClipGamma * sigma;
	prevSample = ClipAABB(minc, maxc, prevSample, mu);
	return prevSample.r;
}

vec2 FetchMotionVector(ivec2 curSampleGPos, ivec2 inSize, ivec2 outSize)
{
	vec2 motion = imageLoad(motionImage, curSampleGPos).rg;
	return motion;
}

vec2 DDXYDepth(ivec2 curSampleGPos, ivec2 inSize)
{
	float depth = imageLoad(normalImage, curSampleGPos).a;

	ivec2 xBiasSampleGPos = curSampleGPos + ivec2(1, 0);
	float xBiasDepth = IsWithinBounds(xBiasSampleGPos, inSize) ? imageLoad(normalImage, xBiasSampleGPos).a : depth;

	ivec2 yBiasSampleGPos = curSampleGPos + ivec2(0, 1);
	float yBiasDepth = IsWithinBounds(yBiasSampleGPos, inSize) ? imageLoad(normalImage, yBiasSampleGPos).a : depth;

	return vec2(xBiasDepth - depth, yBiasDepth - depth);
}

void main()
{
	ivec2 inSize = imageSize(normalImage);
	ivec2 outSize = imageSize(outImage);

	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= outSize.x || gl_GlobalInvocationID.y >= outSize.y) return;

	bool pixelSkip = false; //mod(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y, 2) == mod(frame_number, 2);

	vec2 curTexPos = (gl_GlobalInvocationID.xy + 0.5) / vec2(outSize);
	ivec2 curSamplePos = ivec2(round(curTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 curSampleGPos = ivec2(round(curTexPos * vec2(inSize) - vec2(0.5)));
	vec2 motion = FetchMotionVector(curSampleGPos, inSize, outSize);

	vec2 preTexPos = curTexPos - motion;
	ivec2 prevSamplePos = ivec2(round(preTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 prevSampleGPos = ivec2(round(preTexPos * vec2(inSize) - vec2(0.5)));

	// TODO setup a reproject pass
	if(pixelSkip)
	{
		imageStore(outImage, curSamplePos, imageLoad(prevImage, prevSamplePos));
		imageStore(sqaredMeanVarianceImage, curSamplePos, imageLoad(sqaredMeanVarianceImage, prevSamplePos));
	}

	vec4 prev_normal_depth = imageLoad(prevNormalDepthImage, prevSamplePos);
	vec4 cur_normal_depth = imageLoad(normalImage, curSampleGPos);

	uint tspp = floatBitsToUint(imageLoad(prevImage, prevSamplePos).g);
	float weight = 0.0;

	if(dot(motion, motion) < 1e-2)
	{
		const float normalCutStrength = 1.0;
		float normalWeight = clamp(dot(cur_normal_depth.rgb, prev_normal_depth.rgb) + 1e-5, 0.0, 1.0);
		normalWeight = pow(normalWeight, normalCutStrength);

		vec2 ddxyDepth = DDXYDepth(curSampleGPos, inSize);
		float depthFloatPrecision = 1e-5;
		float depthThreshold = dot(vec2(1.0), abs(ddxyDepth));
		float depthTolerance = depthThreshold + depthFloatPrecision;
		float dpethDelta = abs(prev_normal_depth.a - cur_normal_depth.a);
		dpethDelta = max(0, dpethDelta - depthFloatPrecision);
		float depthWeight = exp(-dpethDelta / depthTolerance);
		weight = normalWeight * depthWeight;
	}

	tspp = uint(float(tspp) * weight);
	float prev_occlusion = 0.0;
	vec2 prev_sqaredmean_variance = vec2(0.0);
	vec2 localMeanVariance = vec2(0.0);
	if(tspp > 0)
	{
		float prev_occlusion_unclamp = 0.0;
		prev_occlusion_unclamp = imageLoad(prevImage, prevSamplePos).r;
		localMeanVariance = imageLoad(meanInputImage, curSamplePos).rg;
		prev_occlusion = ClampPrevResult(prev_occlusion_unclamp, localMeanVariance).r;
		prev_occlusion = prev_occlusion_unclamp;
		// Scale down the tspp based on how strongly the cached value got clamped to give more weight to new samples.
		const float clampDifferenceToTsppScale = 4.0;
		tspp = uint(mix(float(tspp), 0.0, clamp(clampDifferenceToTsppScale * abs(prev_occlusion_unclamp - prev_occlusion), 0.0, 1.0)));
		prev_sqaredmean_variance = imageLoad(sqaredMeanVarianceImage, prevSamplePos).rg;
	}

	const uint maxTspp = 100;
	tspp = min(tspp + 1, maxTspp);

	float occlusion = imageLoad(curImage, curSamplePos).r;
	float sqaredmean = occlusion * occlusion;
	float variance = localMeanVariance.g;
	if(tspp > 0)
	{
		const float maxBlend = 1.0;
		const float minBlend = 1.0 / float(maxTspp);
		float blend = max(minBlend, min(1.0 / float(tspp), 1.0));
		// blend = mix(blend, maxBlend, clamp(length(motion * vec2(outSize) / 40.0), 0.0, 1.0));
		occlusion = mix(prev_occlusion, occlusion, blend);
		sqaredmean = mix(prev_sqaredmean_variance.r, sqaredmean, blend);
		if(tspp > 4)
		{
			variance = sqaredmean - occlusion * occlusion;
		}
	}

	imageStore(outImage, curSamplePos, vec4(occlusion, uintBitsToFloat(tspp), 0, 0));
	imageStore(sqaredMeanVarianceImage, curSamplePos, vec4(sqaredmean, variance, 0, 0));
	imageStore(curNormalDepthImage, curSamplePos, cur_normal_depth);
	// imageStore(outImage, curSamplePos, vec4(weight));
}