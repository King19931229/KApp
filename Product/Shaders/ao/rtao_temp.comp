#include "sampling.h"
#include "rtao_define.h"

layout(binding = BINDING_GBUFFER_NORMAL, rgba32f) uniform image2D normalImage;
layout(binding = BINDING_GBUFFER_POSITION, rgba32f) uniform image2D positionImage;
layout(binding = BINDING_PREV_NORMAL_DEPTH, rgba32f) uniform image2D prevNormalDepthImage;
layout(binding = BINDING_CUR_NORMAL_DEPTH, rgba32f) uniform image2D curNormalDepthImage;
layout(binding = BINDING_VELOCITY, rg32f) uniform image2D motionImage;
layout(binding = BDINING_UNIFORM) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};

layout(binding = BINDING_TEMPORAL_SQAREDMEAN_VARIANCE, rg16f) uniform image2D sqaredMeanVarianceImage;
layout(binding = BINDING_PREV, rg32f) uniform image2D prevImage;
layout(binding = BINDING_CUR, rg16f) uniform image2D curImage;
layout(binding = BINDING_LOCAL_MEAN_VARIANCE_INPUT, rg16f) uniform image2D meanInputImage;
layout(binding = BINDING_FINAL, rg32f) uniform image2D outImage;

#define PREFER_CLIP_THAN_CLAMP
#define CLIP_TO_CENTER

vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 prevSample, vec3 avg)
{
#ifdef PREFER_CLIP_THAN_CLAMP
#ifdef CLIP_TO_CENTER
	// note: only clips towards aabb center (but fast!)
	vec3 p_clip = 0.5 * (aabbMax + aabbMin);
	vec3 e_clip = 0.5 * (aabbMax - aabbMin);

	vec3 v_clip = prevSample - p_clip;
	vec3 v_unit = v_clip.xyz / e_clip;
	vec3 a_unit = abs(v_unit);
	float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

	if (ma_unit > 1.0)
		return p_clip + v_clip / ma_unit;
	else
		return prevSample;// point inside aabb
#else // CLIP_TO_CENTER
	vec3 r = prevSample - avg;
	vec3 rmax = aabbMax - avg.xyz;
	vec3 rmin = aabbMin - avg.xyz;

	const float eps = 0.000001f;

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return avg + r;
#endif
#else // PREFER_CLIP_THAN_CLAMP
	return clamp(prevSample, aabbMin, aabbMax);
#endif
}

// #define SMALL_OFFSET

#ifdef SMALL_OFFSET
#define OFFSET_ARRAY_SIZE 4
#else
#define OFFSET_ARRAY_SIZE 8
#endif

const ivec2 offset[OFFSET_ARRAY_SIZE] = 
{
	ivec2(-1, -1), ivec2(-1, 1),
#ifndef SMALL_OFFSET
	ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0),
#endif
	ivec2(1, -1), ivec2(1, 1)
};

float ClampPrevResult(float unclamp, vec2 localMeanVariance)
{
	const vec3 VarianceClipGamma = vec3(1.0);
	float sigma = sqrt(localMeanVariance.g);
	vec3 mu = vec3(localMeanVariance.r);
	vec3 minc = mu - VarianceClipGamma * sigma;
	vec3 maxc = mu + VarianceClipGamma * sigma;
	vec3 prevSample = ClipAABB(minc, maxc, vec3(unclamp), mu);
	return prevSample.r;
}

vec2 DDXYDepth(ivec2 curSamplePos, ivec2 outSize)
{
	float depth = imageLoad(curNormalDepthImage, curSamplePos).a;

	ivec2 xBiasSampleGPos = curSamplePos + ivec2(1, 0);
	float xBiasDepth = IsWithinBounds(xBiasSampleGPos, outSize) ? imageLoad(curNormalDepthImage, xBiasSampleGPos).a : depth;

	ivec2 yBiasSampleGPos = curSamplePos + ivec2(0, 1);
	float yBiasDepth = IsWithinBounds(yBiasSampleGPos, outSize) ? imageLoad(curNormalDepthImage, yBiasSampleGPos).a : depth;

	return vec2(xBiasDepth - depth, yBiasDepth - depth);
}

void ComputeValues(vec2 p, in out vec4 prevNormalDepth, in out vec2 sqaredMeanVariance, in out vec2 prevValue)
{
	const ivec2 offsets[4] = { {0, 0}, {1, 0}, {0, 1}, {1, 1} };
	ivec2 topLeft = ivec2(floor(p));
	ivec2 closest = ivec2(round(p));

	ivec2 samplePos[4];
	for(int i = 0; i < 4; ++i)
	{
		samplePos[i] = topLeft + offsets[i];
	}

	vec4 sampleNormalDepth[4];
	vec2 sampleValue[4];
	for(int i = 0; i < 4; ++i)
	{
		sampleNormalDepth[i] = imageLoad(prevNormalDepthImage, samplePos[i]).rgba;
		sampleValue[i] = imageLoad(prevImage, samplePos[i]).rg;
	}

	vec2 targetOffset = p - vec2(topLeft);
	ivec2 size = imageSize(prevImage);

	vec4 weights;
	ComputeWeights(targetOffset, size, samplePos, weights);
	weights /= dot(vec4(1.0), weights);

	vec3 normal = vec3(0.0);
	float depth = 0.0;
	float value = 0.0;
	float tspp = 0.0;
	for(int i = 0; i < 4; ++i)
	{
		normal += sampleNormalDepth[i].rgb * weights[i];
		depth += sampleNormalDepth[i].a * weights[i];
		value += sampleValue[i].r * weights[i];
		tspp += floatBitsToUint(sampleValue[i].g) * weights[i];
	}

	prevValue = vec2(value, uintBitsToFloat(uint(round(tspp))));
	prevNormalDepth = vec4(normalize(normal), depth);
	sqaredMeanVariance = imageLoad(sqaredMeanVarianceImage, closest).rg;
}

vec2 ComputeMotion(vec2 p)
{
	const ivec2 offsets[4] = { {0, 0}, {1, 0}, {0, 1}, {1, 1} };
	ivec2 topLeft = ivec2(floor(p));

	ivec2 samplePos[4];
	for(int i = 0; i < 4; ++i)
	{
		samplePos[i] = topLeft + offsets[i];
	}

	vec2 targetOffset = p - vec2(topLeft);
	ivec2 size = imageSize(motionImage);

	vec4 weights;
	ComputeWeights(targetOffset, size, samplePos, weights);
	weights /= dot(vec4(1.0), weights);

	vec2 motion = vec2(0);
	for(int i = 0; i < 4; ++i)
	{
		motion += imageLoad(motionImage, samplePos[i]).rg * weights[i];
	}
	return motion;
}

void main()
{
	ivec2 inSize = imageSize(normalImage);
	ivec2 outSize = imageSize(outImage);

	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= outSize.x || gl_GlobalInvocationID.y >= outSize.y) return;
	ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);

	bool pixelSkip = false;//mod(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y, 2) == mod(frame_number, 2);

	vec2 curTexPos = (gl_GlobalInvocationID.xy + 0.5) / vec2(outSize);
	vec2 curSampleGPos = vec2(curTexPos * vec2(inSize) - vec2(0.5));
	vec2 motion = ComputeMotion(curSampleGPos);
	vec2 preTexPos = curTexPos - motion;

	vec2 reprojectPos = vec2(preTexPos * vec2(outSize) - vec2(0.5));

	vec4 prevNormalDepth = vec4(0.0);
	vec2 prevSqaredmeanVariance = vec2(0.0);
	vec2 prevValue = vec2(0.0);

	ComputeValues(reprojectPos, prevNormalDepth, prevSqaredmeanVariance, prevValue);

	if(pixelSkip)
	{
		imageStore(outImage, storePos, vec4(prevValue, 0, 0));
		imageStore(sqaredMeanVarianceImage, storePos, vec4(prevSqaredmeanVariance, 0, 0));
	}

	vec4 curNormalDepth = imageLoad(curNormalDepthImage, storePos);

	uint tspp = floatBitsToUint(prevValue.g);
	float weight = 0.0;

	if(abs(motion.x) < 1e-2)
	{
		float normalFloatPrecision = 1e-5;
		const float normalCutStrength = 0.8;
		float normalWeight = clamp(dot(curNormalDepth.rgb, prevNormalDepth.rgb) + normalFloatPrecision, 0.0, 1.0);
		normalWeight = pow(normalWeight, normalCutStrength);

		float depthFloatPrecision = 30.0;
		vec2 ddxyDepth = DDXYDepth(ivec2(gl_GlobalInvocationID.xy), outSize);
		float depthThreshold = dot(vec2(1.0), abs(ddxyDepth));
		float depthTolerance = depthThreshold + depthFloatPrecision;
		float dpethDelta = abs(prevNormalDepth.a - curNormalDepth.a);
		dpethDelta = max(0, dpethDelta - depthFloatPrecision);
		float depthWeight = exp(-dpethDelta / depthTolerance);
		weight = normalWeight * depthWeight;
	}

	tspp = uint(float(tspp) * weight);
	float prevOcclusion = 0.0;
	vec2 localMeanVariance = vec2(0.0);
	if(tspp > 0)
	{
		// r: mean, g:sqare_mean, b:variance, a:dummy
		localMeanVariance = imageLoad(meanInputImage, storePos).rb;
		prevOcclusion = ClampPrevResult(prevValue.r, localMeanVariance).r;
		// Scale down the tspp based on how strongly the cached value got clamped to give more weight to new samples.
		const float clampDifferenceToTsppScale = 4.0;
		tspp = uint(mix(float(tspp), 0.0, clamp(clampDifferenceToTsppScale * abs(prevValue.r - prevOcclusion), 0.0, 1.0)));
	}

	float occlusion = imageLoad(curImage, storePos).r;
	float sqaredmean = occlusion * occlusion;
	float variance = localMeanVariance.g;

	const uint maxTspp = 100;
	if(tspp > 0)
	{
		const float maxBlend = 1.0;
		const float minBlend = 1.0 / float(maxTspp);
		float blend = max(minBlend, min(1.0 / float(tspp + 1), maxBlend));
		occlusion = mix(prevOcclusion, occlusion, blend);
		sqaredmean = mix(prevSqaredmeanVariance.r, sqaredmean, blend);
		if(tspp > 4)
		{
			variance = sqaredmean - occlusion * occlusion;
		}
	}
	tspp = min(tspp + 1, maxTspp);

	imageStore(outImage, storePos, vec4(occlusion, uintBitsToFloat(tspp), 0, 0));
	imageStore(sqaredMeanVarianceImage, storePos, vec4(sqaredmean, variance, 0, 0));
}