#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

const int GROUP_SIZE = 32;

#include "sampling.h"
#include "rtao_define.h"

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(binding = BINDING_GBUFFER_NORMAL, rgba32f) uniform image2D inImage0;
layout(binding = BINDING_GBUFFER_POSITION, rgba32f) uniform image2D inImage1;
layout(binding = BINDING_VELOCITY, rg32f) uniform image2D inImage2;
layout(binding = BINDING_AS) uniform accelerationStructureEXT topLevelAS;
layout(binding = BDINING_UNIFORM) uniform AOProperties 
{
	float rtao_radius;
	int   rtao_samples;
	float rtao_power;
	int   rtao_distance_based;
	int   max_samples;
	int   frame_number;
};
layout(binding = BINDING_PREV, rg32f) uniform image2D prevImage;
layout(binding = BINDING_CUR, rg32f) uniform image2D curImage;
layout(binding = BINDING_MEAN_VARIANCE_INPUT, rg32f) uniform image2D meanInputImage;
layout(binding = BINDING_FINAL, rg32f) uniform image2D outImage;

vec3 ClipAABB(vec3 aabbMin, vec3 aabbMax, vec3 prevSample, vec3 avg)
{
#ifdef CLIP_TO_CENTER
	// note: only clips towards aabb center (but fast!)
	vec3 p_clip = 0.5 * (aabbMax + aabbMin);
	vec3 e_clip = 0.5 * (aabbMax - aabbMin);

	vec3 v_clip = prevSample - p_clip;
	vec3 v_unit = v_clip.xyz / e_clip;
	vec3 a_unit = abs(v_unit);
	float ma_unit = max(a_unit.x, max(a_unit.y, a_unit.z));

	if (ma_unit > 1.0)
		return p_clip + v_clip / ma_unit;
	else
		return prevSample;// point inside aabb
#else
	vec3 r = prevSample - avg;
	vec3 rmax = aabbMax - avg.xyz;
	vec3 rmin = aabbMin - avg.xyz;

	const float eps = 0.000001f;

	if (r.x > rmax.x + eps)
		r *= (rmax.x / r.x);
	if (r.y > rmax.y + eps)
		r *= (rmax.y / r.y);
	if (r.z > rmax.z + eps)
		r *= (rmax.z / r.z);

	if (r.x < rmin.x - eps)
		r *= (rmin.x / r.x);
	if (r.y < rmin.y - eps)
		r *= (rmin.y / r.y);
	if (r.z < rmin.z - eps)
		r *= (rmin.z / r.z);

	return avg + r;
#endif
}

// #define SMALL_OFFSET

#ifdef SMALL_OFFSET
#define OFFSET_ARRAY_SIZE 4
#else
#define OFFSET_ARRAY_SIZE 8
#endif

const ivec2 offset[OFFSET_ARRAY_SIZE] = 
{
	ivec2(-1, -1), ivec2(-1, 1),
#ifndef SMALL_OFFSET
	ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0),
#endif
	ivec2(1, -1), ivec2(1, 1)
};

bool IsWithinBounds(ivec2 pos, ivec2 size)
{
	return pos.x >= 0 && pos.y >= 0 && pos.x < size.x && pos.y < size.y;
}

float FetchPrevResult(ivec2 prevSamplePos, ivec2 curSamplePos, ivec2 outSize)
{
	const float VarianceClipGamma = 1.0;
#if 0
	vec3 prevSample = imageLoad(prevImage, prevSamplePos).rrr;
	vec3 curSample = imageLoad(curImage, curSamplePos).rrr;
	vec3 sumSample = curSample;
	vec3 squareSumSample = curSample * curSample;

	float N = 1;
	for(int i = 0; i < OFFSET_ARRAY_SIZE; ++i)
	{
		ivec2 samplePos = curSamplePos + offset[i];
		if(IsWithinBounds(samplePos, outSize))
		{
			vec3 result = imageLoad(prevImage, samplePos).rrr;
			sumSample += result;
			squareSumSample += result * result;
			++N;
		}
	}
	if(N > 1)
	{
		// Variance clip.
		vec3 mu = sumSample / N;
		vec3 sigma = sqrt(abs(squareSumSample / N - mu * mu));
		vec3 minc = mu - VarianceClipGamma * sigma;
		vec3 maxc = mu + VarianceClipGamma * sigma;

		prevSample.rgb = ClipAABB(minc.rgb, maxc.rgb, prevSample.rgb, mu.rgb);
		return prevSample.r;
	}
	else
	{
		return curSample.r;
	}
#else
	vec3 prevSample = imageLoad(prevImage, prevSamplePos).rrr;
	vec2 meanVariance = imageLoad(meanInputImage, curSamplePos).rg;
	float _sigma = sqrt(meanVariance.g);
	vec3 sigma = vec3(_sigma);
	vec3 mu = vec3(meanVariance.r);
	vec3 minc = mu - VarianceClipGamma * sigma;
	vec3 maxc = mu + VarianceClipGamma * sigma;

	prevSample.rgb = ClipAABB(minc.rgb, maxc.rgb, prevSample.rgb, mu.rgb);
	return prevSample.r;
#endif
}

vec2 FetchMotionVector(ivec2 curSampleGPos, ivec2 inSize, ivec2 outSize)
{
	ivec2 minSamplePos = curSampleGPos;
	float minDepth = imageLoad(inImage0, curSampleGPos).a;

	for(int i = 0; i < OFFSET_ARRAY_SIZE; ++i)
	{
		ivec2 samplePos = curSampleGPos + offset[i];
		if(IsWithinBounds(samplePos, inSize))
		{
			float result = imageLoad(inImage0, samplePos).a;
			if(result < minDepth)
			{
				minDepth = result;
				minSamplePos = samplePos;
			}
		}
	}

	vec2 motion = imageLoad(inImage2, minSamplePos).rg;
	motion = (motion * vec2(outSize)) / vec2(outSize);
	return motion;
}

vec2 DDXYDepth(ivec2 curSampleGPos, ivec2 inSize)
{
	float depth = imageLoad(inImage0, curSampleGPos).a;

	ivec2 xBiasSampleGPos = curSampleGPos + ivec2(1, 0);
	float xBiasDepth = IsWithinBounds(xBiasSampleGPos, inSize) ? imageLoad(inImage0, xBiasSampleGPos).a : depth;

	ivec2 yBiasSampleGPos = curSampleGPos + ivec2(0, 1);
	float yBiasDepth = IsWithinBounds(yBiasSampleGPos, inSize) ? imageLoad(inImage0, yBiasSampleGPos).a : depth;

	return vec2(xBiasDepth - depth, yBiasDepth - depth);
}

void main()
{
	ivec2 inSize = imageSize(inImage0);
	ivec2 outSize = imageSize(outImage);

	// Check if not outside boundaries
	if(gl_GlobalInvocationID.x >= outSize.x || gl_GlobalInvocationID.y >= outSize.y) return;

	if(mod(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y, 2) == mod(frame_number, 2)) return;

	vec2 curTexPos = (gl_GlobalInvocationID.xy + 0.5) / vec2(outSize);
	ivec2 curSamplePos = ivec2(round(curTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 curSampleGPos = ivec2(round(curTexPos * vec2(inSize) - vec2(0.5)));
	vec2 motion = FetchMotionVector(curSampleGPos, inSize, outSize);

	vec2 preTexPos = curTexPos - motion;
	ivec2 prevSamplePos = ivec2(round(preTexPos * vec2(outSize) - vec2(0.5)));
	ivec2 prevSampleGPos = ivec2(round(preTexPos * vec2(inSize) - vec2(0.5)));

	vec4 prev_normal_depth = imageLoad(inImage0, curSampleGPos);
	vec4 cur_normal_depth = imageLoad(inImage0, prevSampleGPos);

	uint tspp = floatBitsToUint(imageLoad(prevImage, prevSamplePos).g);
	float prev = 0.0;
	float weight = 0.0;

	if(dot(motion, motion) < 1e-4)
	{
		prev = FetchPrevResult(prevSamplePos, curSamplePos, outSize).r;
		float normalWeight = clamp(dot(cur_normal_depth.rgb, prev_normal_depth.rgb), 0.0, 1.0);
		normalWeight = pow(normalWeight, 1.0);

		vec2 ddxyDepth = DDXYDepth(curSampleGPos, inSize);
		float precisionNum = 1e-10;
		float depthThreshold = dot(vec2(1.0), abs(ddxyDepth));
		float depthTolerance = 1e5 * depthThreshold + precisionNum;

		float depthWeight = min(depthTolerance / (abs(prev_normal_depth.a - cur_normal_depth.a) + precisionNum), 1);
		// FIXME: Why Jitter happens when precisionNum is 0
		depthWeight = max(depthWeight, 0.0);
		depthWeight = pow(depthWeight, 1.0);

		weight = normalWeight * depthWeight;
	}

	if(weight < 1e-2)
	{
		tspp = 0;
	}

	tspp = uint(round(float(tspp) * weight));

	if(tspp >= max_samples && dot(motion, motion) < 1e-4) return;

	float occlusion = imageLoad(curImage, curSamplePos).r;
	if(tspp != 0)
	{
		const float maxBlend = 0.5;
		const float minBlend = 0.01;
		float blend = max(minBlend, min(1.0 / float(tspp + 1), maxBlend));
		blend = mix(blend, maxBlend, clamp(length(motion * vec2(outSize)), 0.0, 1.0));
		blend = mix(blend, 1.0, 1.0 - weight);
		occlusion = mix(prev, occlusion, blend);
	}

	imageStore(outImage, curSamplePos, vec4(occlusion, uintBitsToFloat(tspp + 1), 0, 0));
}