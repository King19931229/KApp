#include "public.h"
#include "voxelcommon.h"

#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = GROUP_SIZE) in;

layout(binding = VOXEL_BINDING_ALBEDO) uniform sampler3D voxelAlbedo;
layout(binding = VOXEL_BINDING_NORMAL, rgba8) uniform image3D voxelNormal;
layout(binding = VOXEL_BINDING_RADIANCE, rgba8) uniform writeonly image3D voxelRadiance;
layout(binding = VOXEL_BINDING_EMISSION_MAP, rgba8) uniform readonly image3D voxelEmissive;

const float EPSILON = 1e-30;

vec3 VoxelToWorld(ivec3 pos)
{
	vec3 result = vec3(pos);
	result *= voxel.miscs2[0];
	return result + voxel.minpoint_scale.xyz;;
}

vec3 WorldToVoxel(vec3 position)
{
	vec3 voxelPos = position - voxel.minpoint_scale.xyz;
	return voxelPos * voxel.minpoint_scale.w;
}

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) 
{
	// scaling factor
	float k = voxel.miscs3[1] * voxel.miscs3[1];
	// navigation
	float voxelTexSize = 1.0f / voxel.miscs[0];
	// move one voxel further to avoid self collision
	float dst = voxelTexSize * 2.0f;
	vec3 samplePos = direction * dst + position;
	// control variables
	float visibility = 0.0f;
	// accumulated sample
	float traceSample = 0.0f;

	while (visibility <= 1.0f && dst <= maxTracingDistance) 
	{
		if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
			|| samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f) 
		{ 
			break; 
		}
		
		traceSample = ceil(texture(voxelAlbedo, samplePos).a) * k;

		// hard shadows mode
		if(traceSample > 1.0f - EPSILON) { return 0.0f; }

		// accumulate
		visibility += (1.0f - visibility) * traceSample / dst;
		// move further into volume
		dst += voxelTexSize;
		samplePos = direction * dst + position;
	}

	return 1.0f - visibility;
}

vec3 BRDF(Light light, vec3 normal, vec3 albedo)
{
	float nDotL = 0.0f;

	if(voxel.miscs[2] == 1)
	{
		vec3 weight = normal * normal;
		// calculate directional normal attenuation
		float rDotL = dot(vec3(1.0, 0.0, 0.0), light.direction);
		float uDotL = dot(vec3(0.0, 1.0, 0.0), light.direction);
		float fDotL = dot(vec3(0.0, 0.0, 1.0), light.direction);

		rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
		uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
		fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
		// voxel shading average from all front sides
		nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;
	}
	else
	{
		nDotL = max(dot(normal, light.direction), 0.0f);
	}

	return light.diffuse * albedo * nDotL;
}

#include "voxel_lighting.h"

void main()
{
	if(gl_GlobalInvocationID.x >= voxel.miscs[0] ||
		gl_GlobalInvocationID.y >= voxel.miscs[0] ||
		gl_GlobalInvocationID.z >= voxel.miscs[0]) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);
	// voxel color
	vec4 albedo = texelFetch(voxelAlbedo, writePos, 0);

	if(albedo.a < EPSILON) { return; }

	albedo.a = 0.0f;
	// voxel normal in 0-1 range
	vec3 baseNormal = imageLoad(voxelNormal, writePos).xyz;
	// normal is stored in 0-1 range, restore to -1-1
	vec3 normal = DecodeNormal(baseNormal);
	// emission from voxel
	vec3 emissive = imageLoad(voxelEmissive, writePos).rgb;

	// black voxel has no irradiance diffuse
	if(any(greaterThan(albedo.rgb, vec3(0.0f))))
	{
		// obtain world-space position of the current voxel
		vec3 wsPosition = VoxelToWorld(writePos);
		// calculate direct lighting onto voxel
		albedo = CalculateDirectLighting(wsPosition, normal, albedo.rgb);
	}

	// store visibility in normal alpha
	imageStore(voxelNormal, writePos, vec4(baseNormal, albedo.a));

	// add emission
	albedo.rgb += emissive;
	albedo.a = 1.0f;

	imageStore(voxelRadiance, writePos, albedo);
}