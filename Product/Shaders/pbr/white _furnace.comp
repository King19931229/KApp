const float PI = 3.14159265f;
const float HALF_PI = 1.57079f;

#include "pbr.h"

#define GROUP_SIZE 32

layout (local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

void main()
{
	ivec2 size = imageSize(resultImage).xy;
	// Check if not outside boundaries
	if (gl_GlobalInvocationID.x >= size.x || gl_GlobalInvocationID.y >= size.y) return;
	const ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
	const vec2 uv = vec2(texCoord.xy) / size;

	const float roughness = uv.x;
	const float nDotV = uv.y;

	const int steps = 32;
	const float deltaTheta = 0.5 * PI / steps;
	const float deltaPhi = 2.0 * PI / steps;

	float integral = 0;

	vec3 n = vec3(0, 0, 1);
	vec3 v = vec3(sin(nDotV), 0, cos(nDotV));
	for (int i = 0; i < steps; ++i)
	{
		const float theta = i * deltaTheta;
		for (int j = 0; j < steps; ++j)
		{
			const float phi = j * deltaPhi;
			const vec3 l = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));
			const vec3 h = normalize(v + l);

			const float D = DistributionGGX(v, h, roughness);
			const float G = GeometrySchlickGGXJoint(n, v, l, roughness);

			// pdf(theta, phi) 		=  1 / (PI * PI)
			// pdf(w) 				= pdf(theta, phi) / sin(theta)
			//						= 1 / (PI * PI * sin(theta))
			// 1.0 / pdf(w)			= sin(theta) * PI * PI
			// N 					= PI * PI / (deltaTheta * deltaPhi)
			// 1.0 / N				= deltaTheta * deltaPhi / (PI * PI)
			// 1.0 / (N * pdf(w)) 	= deltaTheta * deltaPhi * sin(theta)

			integral += sin(theta) * D * G / (4.0 * dot(n, v));
		}
	}

	integral *= deltaTheta * deltaPhi;

	imageStore(resultImage, texCoord, vec4(integral));
}