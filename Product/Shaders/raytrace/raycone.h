#ifndef RAY_CONE_H
#define RAY_CONE_H

#include "raycommon.h"

vec3 DecodeNormal(vec2 uv)
{
	return texture(encodedGBuffer0, uv).rgb;
}

vec3 DecodePosition(vec2 uv)
{
	return texture(encodedGBuffer1, uv).rgb;
}

vec3 DD_Normal(vec2 uv, vec2 axis)
{
	vec2 eps = sign(axis) / vec2(textureSize(encodedGBuffer0, 0));
	vec3 d = vec3(0.0);
	vec3 center;
	center = DecodeNormal(uv);
	d += DecodeNormal(uv + eps) - center;
	d += center - DecodeNormal(uv - eps);
	return d * 0.5;
}

vec3 DD_Position(vec2 uv, vec2 axis)
{
	vec2 eps = sign(axis) / vec2(textureSize(encodedGBuffer1, 0));
	vec3 d = vec3(0.0);
	vec3 center;
	center = DecodePosition(uv);
	d += DecodePosition(uv + eps) - center;
	d += center - DecodePosition(uv - eps);
	return d * 0.5;
}

float PixelSpreadAngle()
{
	// Eq. 30
	float fov = 3.14 * 45.0 / 360.0;
	float a = atan(2.0 * tan(fov / 2) / float(textureSize(encodedGBuffer0, 0).r));
	return a;
}

 RayCone Propagate(RayCone cone, float surfaceSpreadAngle, float hitT)
 {
	RayCone newCone;
	newCone.width = cone.spreadAngle * hitT + cone.width;
	newCone.spreadAngle = cone.spreadAngle + surfaceSpreadAngle;
 	return newCone;
 }

RayCone ComputeRayConeFromGBuffer(SurfaceHit gbuffer, float hitT)
{
	RayCone rc;
	rc.width = 0; // No width when ray cone starts
	rc.spreadAngle = PixelSpreadAngle(); // Eq. 30
	// gbuffer.surfaceSpreadAngle holds a value generated by Eq. 32
	return Propagate(rc, gbuffer.surfaceSpreadAngle, hitT);
}

float ComputeTriangleArea(Pixel pixel)
{
	vec3 v = cross(pixel.p1 - pixel.p0, pixel.p2 - pixel.p0);
	float P_a = sqrt(abs(dot(v, v)));
	return P_a;
}

float ComputeTextureCoordsArea(Pixel pixel)
{
	float T_a = (pixel.t1.x - pixel.t0.x) * (pixel.t2.y - pixel.t0.y);
	T_a -= (pixel.t2.x - pixel.t0.x) * (pixel.t1.y - pixel.t0.y);
	T_a = abs(T_a);
	return T_a;
}

float GetTriangleLODConstant(Pixel pixel)
{
	float P_a = ComputeTriangleArea(pixel); // Eq. 5
	float T_a = ComputeTextureCoordsArea(pixel); // Eq. 4
	return 0.5 * log2 (T_a / P_a); // Eq. 3
}

float ComputeTextureLOD(vec3 rayDir, vec3 surfNormal, RayCone cone, Pixel pixel)
{
	// Eq. 34
	float lambda = GetTriangleLODConstant(pixel);
	lambda += log2(abs(cone.width));
	lambda -= log2(abs(dot(rayDir, surfNormal)));
	lambda += 0.5 * log2(pixel.wh);
	return lambda;
}

SurfaceHit InitializeSurfaceHit(in vec3 camera, in vec2 uv)
{
	SurfaceHit gbuffer;

	float K_1 = 0.003;
	float K_2 = 0.0003;

	vec3 DDP_X = DD_Position(uv, vec2(1.0, 0.0));
	vec3 DDP_Y = DD_Position(uv, vec2(0.0, 1.0));
	vec3 DDN_X = DD_Normal(uv, vec2(1.0, 0.0));
	vec3 DDN_Y = DD_Normal(uv, vec2(0.0, 1.0));

	float S = sign(dot(DDP_X, DDN_X) + dot(DDP_Y, DDN_Y));
	float T = sqrt(dot(DDN_X, DDN_X) + dot(DDN_Y, DDN_Y));

	gbuffer.surfaceSpreadAngle = 2.0 * K_1 * S * T + K_2;

	return gbuffer;
}

#endif