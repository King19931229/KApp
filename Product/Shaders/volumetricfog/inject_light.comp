#define COMPUTE_SHADER
#include "volumetric_fog_public.h"
#include "sampling.h"
#include "shadow/cascadedshadow_static.h"
#include "shadow/cascadedshadow_dynamic.h"

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = GROUP_SIZE) in;

layout(binding = BINDING_VOXEL_PREV) uniform sampler3D prevVoxel;
layout(binding = BINDING_VOXEL_CURR, rgba8) uniform writeonly image3D currVoxel;

// Henyey-Greenstein
float PhaseFunction(vec3 Wo, vec3 Wi, float g)
{
	float cos_theta = dot(Wo, Wi);
	float denom = 1.0f + g * g + 2.0f * g * cos_theta;
	return (1.0f / (4.0f * PI)) * (1.0f - g * g) / max(pow(denom, 1.5f), EPSILON);
}

void main()
{
	ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
	ivec3 size = imageSize(currVoxel).xyz;
	vec3 grid_size = vec3(size);
	vec3 grid = vec3(coord);
	if (coord.x >= size.x || coord.y >= size.y || coord.z > size.z) return;

	uint seed = TEA(size.y * size.x * coord.z + size.x * coord.y + coord.x, object.frameNum);
	float jitter = (RND(seed) - 0.5f);

	vec3 worldPos = IDToWorldWithJitter(coord, object.nearFarGridZ.x, object.nearFarGridZ.y, jitter, object.proj, object.invViewProj, grid_size.x, grid_size.y, grid_size.z);
	vec3 Wo = normalize(object.cameraPos.xyz - worldPos);
	vec3 Wi = -global.sunLightDir.xyz;

	float aniso = object.anisotropyDensityScatteringAbsorption.x;
	float density = object.anisotropyDensityScatteringAbsorption.y;

	float visibility = min(CalcDynamicCSM(worldPos).r, CalcStaticCSM(worldPos).r);

	vec3 lighting = vec3(0);
	vec4 lightColor = vec4(50.0);
	if (visibility > EPSILON)
		lighting += visibility * lightColor.xyz * PhaseFunction(Wo, Wi, aniso);

	vec4 colorAndDensity = vec4(lighting * density, density);

	vec3 worldPosWithoutJitter = IDToWorldWithoutJitter(coord, object.nearFarGridZ.x, object.nearFarGridZ.y, object.proj, object.invViewProj, grid_size.x, grid_size.y, grid_size.z);
	vec3 historyUV = WorldToUV(worldPos, object.prevViewProj, object.prevProj, object.nearFarGridZ.x, object.nearFarGridZ.y, grid_size.z);

	// If history UV is outside the frustum, skip history
	if (all(greaterThanEqual(historyUV, vec3(0.0f))) && all(lessThanEqual(historyUV, vec3(1.0f))))
	{
		// Fetch history sample
		vec4 history = textureLod(prevVoxel, historyUV, 0.0f);
		colorAndDensity = mix(history, colorAndDensity, 0.05f);
		//vec3 uv = (vec3(coord) + vec3(0.5)) / grid_size;
		//colorAndDensity = vec4(100 * abs(historyUV - uv), 1);
	}

	imageStore(currVoxel, coord, colorAndDensity);
}