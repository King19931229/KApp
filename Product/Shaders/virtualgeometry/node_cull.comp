#include "vg_define.h"
#include "culling.h"

shared uint SharedCandidateNodeBatch[BVH_MAX_GROUP_BATCH_SIZE];

#define DEBUG_SHADER_GROUP 0

bool IsSharedHierarchyDataValid(uint index)
{
	return SharedCandidateNodeBatch[index] != 0xFFFFFFFF;
}

void ProcessNodeBatch(uint groupIndex, uint batchStart, uint batchSize)
{
	uint localIndex = groupIndex / BVH_MAX_NODES;
	uint childIndex = groupIndex & BVH_NODE_MASK;

#if DEBUG_SHADER_GROUP
	uint globalIndex = batchStart + localIndex;
	if (localIndex >= batchSize)
	{
		return;
	}
	CandidateNode nodeBatch = UnpackCandidateNode(CandidateNodeBatch[globalIndex]);
#else
	if (!IsSharedHierarchyDataValid(localIndex))
	{
		return;
	}
	CandidateNode nodeBatch = UnpackCandidateNode(SharedCandidateNodeBatch[localIndex]);
#endif

	uint instanceId = nodeBatch.instanceId;
	uint resourceIndex = InstanceData[instanceId].resourceIndex;

	ClusterHierarchyStruct hierarchy;
	GetHierarchyData(nodeBatch, hierarchy);

	uint isLeaf = hierarchy.isLeaf;

	mat4 localToWorld = InstanceData[instanceId].transform;

	vec3 boundCenter = hierarchy.lodBoundCenterError.xyz;
	vec3 boundHalfExtend = hierarchy.lodBoundHalfExtendRadius.xyz;
	float maxParentError = hierarchy.lodBoundCenterError.w;
	float radius = hierarchy.lodBoundHalfExtendRadius.w;

	FrustumCullData cullData = BoxCullFrustumGeneral(boundCenter.xyz, boundHalfExtend.xyz, localToWorld, worldToClip, true, false);

#if CULL_CLUSTER_ALONG_BVH
	if (cullData.bIsVisible)
	{
		cullData.bIsVisible = ShouldVisitChild(localToWorld, worldToView, boundCenter.xyz, radius, maxParentError);
	}
#endif

	if (!cullData.bIsVisible)
	{
		return;
	}

	if (isLeaf == 0)
	{
		uint nodeIndex = hierarchy.children[childIndex];
		if (nodeIndex != INVALID_INDEX)
		{
			uint nodeWriteOffset = InterlockAddNodeWriteOffset(1);
			if (nodeWriteOffset < MAX_CANDIDATE_NODE)
			{
				CandidateNode node;
				node.instanceId = instanceId;
				node.nodeIndex = nodeIndex;
				StoreCandidateNode(nodeWriteOffset, node);
				// ExtraDebugInfo[nodeWriteOffset] = groupIndex; //uint(IsSharedHierarchyDataValid(localIndex));
			}
		}
	}
	// Leaf
	else
	{
		if (childIndex == 0)
		{
			uint clusterStart = hierarchy.clusterStart;
			uint clusterNum = hierarchy.clusterNum;
			uint clusterWriteOffset = InterlockAddClusterWriteOffset(clusterNum);
			for (uint i = 0; i < clusterNum; ++i)
			{
				if (clusterWriteOffset + i >= MAX_CANDIDATE_CLUSTER)
				{
					break;
				}
				CandidateCluster candidateCluster;
				candidateCluster.instanceId = instanceId;
				candidateCluster.clusterIndex = clusterStart + i;
				StoreCandidateCluster(clusterWriteOffset + i, candidateCluster);
			}
		}
	}
}

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;
	uint maxBatchNodes = QueueState[0].nodePrevWriteOffset - QueueState[0].nodeReadOffset;

	uint batchStart = QueueState[0].nodeReadOffset + groupID * BVH_MAX_GROUP_BATCH_SIZE;
	uint batchSize = min(batchStart + BVH_MAX_GROUP_BATCH_SIZE, QueueState[0].nodePrevWriteOffset) - batchStart;

	uint localIndex = groupIndex / BVH_MAX_NODES;
	uint childIndex = groupIndex & BVH_NODE_MASK;

#if !DEBUG_SHADER_GROUP
	bool readData = false;
	uint nodeIndex = batchStart + localIndex;

	if (childIndex == 0)
	{
		if (localIndex < batchSize)
		{
			readData = true;
			SharedCandidateNodeBatch[localIndex] = CandidateNodeBatch[nodeIndex];
		}
		else
		{
			SharedCandidateNodeBatch[localIndex] = 0xFFFFFFFF;
		}
	}
	memoryBarrierShared(); // barrier();
#endif

	ProcessNodeBatch(groupIndex, batchStart, batchSize);

#if !DEBUG_SHADER_GROUP
	if (readData)
	{
		CandidateNodeBatch[nodeIndex] = 0xFFFFFFFF;
	}
#endif
}