#include "vg_define.h"
#include "culling.h"
#include "wave.h"

shared uvec4 SharedCandidateNodeBatch[BVH_MAX_GROUP_BATCH_SIZE];
shared uint SharedNodeBatchReadOffset;
shared uint SharedNodeReadyMask;
shared uint SharedNodeCount;

#define DONT_USE_SHARED_NODE_BATCH 0
#define EMIT_CLUSTER_EACH_THREAD 1

void ProcessNodeBatch(uint groupIndex, uint batchStart, uint batchSize)
{
	uint localIndex = groupIndex / BVH_MAX_NODES;
	uint childIndex = groupIndex & BVH_NODE_MASK;

	uint batchIndex = batchStart + localIndex;
	bool process = localIndex < batchSize;

	if (process)
	{
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
	batchIndex += MAX_CANDIDATE_NODE;
#endif
#if DONT_USE_SHARED_NODE_BATCH
	CandidateNode nodeBatch = UnpackCandidateNode(CandidateNodeBatch[batchIndex]);
#else
	CandidateNode nodeBatch = UnpackCandidateNode(SharedCandidateNodeBatch[localIndex]);
#endif

	uint instanceId = nodeBatch.instanceId;
	uint resourceIndex = InstanceData[instanceId].resourceIndex;

	ClusterHierarchyStruct hierarchy;
	GetHierarchyData(nodeBatch, hierarchy);

	uint isLeaf = hierarchy.isLeaf;
	mat4 localToWorld = InstanceData[instanceId].transform;

	if (isLeaf == 0)
	{
		uint nodeIndex = hierarchy.children[childIndex];
		if (nodeIndex != INVALID_INDEX)
		{
			CandidateNode childBatch;
			childBatch.instanceId = instanceId;
			childBatch.nodeIndex = nodeIndex;

			ClusterHierarchyStruct childHierarchy;
			GetHierarchyData(childBatch, childHierarchy);

			vec3 boundCenter = childHierarchy.lodBoundCenterError.xyz;
			float maxParentError = childHierarchy.lodBoundCenterError.w;
			vec3 boundHalfExtend = childHierarchy.lodBoundHalfExtendRadius.xyz;
			float radius = childHierarchy.lodBoundHalfExtendRadius.w;

			FrustumCullData cullData = BoxCullFrustumGeneral(boundCenter, boundHalfExtend, localToWorld, worldToClip, true, false);

#if CULL_CLUSTER_ALONG_BVH
			if (cullData.bIsVisible)
			{
#if USE_INSTANCE_CENTER_CULL
				cullData.bIsVisible = ShouldVisitChild(localToWorld, worldToView, vec3(0, 0, 0), radius, maxParentError);
#else
				cullData.bIsVisible = ShouldVisitChild(localToWorld, worldToView, boundCenter, radius, maxParentError);
#endif // USE_INSTANCE_CENTER_CULL
			}
#endif // CULL_CLUSTER_ALONG_BVH

#if INSTANCE_CULL_MODE == INSTANCE_CULL_MAIN || INSTANCE_CULL_MODE == INSTANCE_CULL_POST
			if (cullData.bIsVisible)
			{
				ivec2 hzbSize = textureSize(hiZTex, 0);
				ScreenRect rect = GetScreenRect(ivec4(0, 0, hzbSize * 2), cullData, 4);
				cullData.bIsVisible = IsVisibleHZB(rect, hzbSize, true);
			}
#if INSTANCE_CULL_MODE == INSTANCE_CULL_MAIN
			if (!cullData.bIsVisible)
			{
				uint nodeWriteOffset = 0;
				WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_POST_INDEX].nodeWriteOffset, 1, nodeWriteOffset);
				if (nodeWriteOffset < MAX_CANDIDATE_NODE)
				{
					nodeWriteOffset += MAX_CANDIDATE_NODE;
					StoreCandidateNode(nodeWriteOffset, childBatch);
					WAVE_INTERLOCK_ADD_ONLY(QueueState[QUEUE_STATE_POST_INDEX].nodeCount, 1);
				}
			}
#endif // INSTANCE_CULL_MODE == INSTANCE_CULL_MAIN
#endif

			if (cullData.bIsVisible)
			{
				uint nodeWriteOffset = 0;
				WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_INDEX].nodeWriteOffset, 1, nodeWriteOffset);
				if (nodeWriteOffset < MAX_CANDIDATE_NODE)
				{
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
					nodeWriteOffset += MAX_CANDIDATE_NODE;
#endif
					StoreCandidateNode(nodeWriteOffset, childBatch);
					WAVE_INTERLOCK_ADD_ONLY(QueueState[QUEUE_STATE_INDEX].nodeCount, 1);
				}
			}
		}
	}
	// Leaf
	else
	{
#if EMIT_CLUSTER_EACH_THREAD
		uint clusterNumPerChild = hierarchy.clusterNum / BVH_MAX_NODES;
		uint clusterNumPerChildRest = hierarchy.clusterNum & BVH_NODE_MASK;

		uint clusterStart = hierarchy.clusterStart + childIndex * clusterNumPerChild + uint(childIndex != 0) * clusterNumPerChildRest;
		uint clusterNum = clusterNumPerChild + uint(childIndex == 0) * clusterNumPerChildRest;
#else
		uint clusterStart = hierarchy.clusterStart;
		uint clusterNum = 0;
		if (childIndex == 0)
		{
			clusterNum = hierarchy.clusterNum;
		}
#endif
		if (clusterNum > 0)
		{
			uint clusterWriteOffset = 0;
			WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_INDEX].clusterWriteOffset, clusterNum, clusterWriteOffset);

			for (uint i = 0; i < clusterNum; ++i)
			{
				if (clusterWriteOffset + i >= MAX_CANDIDATE_CLUSTER)
				{
					break;
				}
				CandidateCluster candidateCluster;
				candidateCluster.instanceId = instanceId;
				candidateCluster.clusterIndex = clusterStart + i;
				StoreCandidateCluster(clusterWriteOffset + i, candidateCluster);
			}
		}
	}
	}

	barrier();
	if (groupIndex == 0)
	{
		WAVE_INTERLOCK_ADD_ONLY(QueueState[QUEUE_STATE_INDEX].nodeCount, -batchSize);
	}
}

#ifdef PERSISTENT_CULL

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupIndex = gl_LocalInvocationID.x;

	uint processOffset = BVH_MAX_GROUP_BATCH_SIZE;
	uint batchReadOffset = 0;

	bool bProcessNode = true;
	uint loopCounter = 0;

	while (bProcessNode)
	{
		SharedNodeReadyMask = 0;
		barrier();

		if (processOffset == BVH_MAX_GROUP_BATCH_SIZE)
		{
			if (groupIndex == 0)
			{
				WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_INDEX].nodeReadOffset, BVH_MAX_GROUP_BATCH_SIZE, SharedNodeBatchReadOffset);
			}
			barrier();
			processOffset = 0;
			batchReadOffset = SharedNodeBatchReadOffset;
		}

		uint batchStart = batchReadOffset + processOffset;
		uint batchIndex = batchStart + groupIndex;
		bProcessNode = batchIndex < MAX_CANDIDATE_NODE;
		if (!bProcessNode)
		{
			continue;
		}
		bool bNodeReady = processOffset + groupIndex < BVH_MAX_GROUP_BATCH_SIZE;
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
		batchIndex += MAX_CANDIDATE_NODE;
#endif
		if (bNodeReady)
		{
			bNodeReady = CandidateNodeBatch[batchIndex].x != 0xFFFFFFFF;
		}

		if (bNodeReady)
		{
			SharedCandidateNodeBatch[groupIndex] = CandidateNodeBatch[batchIndex];
			atomicOr(SharedNodeReadyMask, 1 << groupIndex);
		}
		barrier();

		uint nodeReadyMask = SharedNodeReadyMask;
		if (nodeReadyMask > 0)
		{
			uint batchSize = findLSB(~nodeReadyMask);
			ProcessNodeBatch(groupIndex, batchStart, batchSize);
			if (groupIndex < batchSize/*bNodeReady*/)
			{
				CandidateNodeBatch[batchIndex] = uvec4(0xFFFFFFFF);
			}
			processOffset += batchSize;
		}

		barrier();
		if (groupIndex == 0)
		{
			SharedNodeCount = QueueState[QUEUE_STATE_INDEX].nodeCount;
		}
		barrier();

		if (SharedNodeCount == 0)
		{
			bProcessNode = false;
		}

		loopCounter += 1;
		if (loopCounter >= 1000)
		{
			break;
		}
	}
}

#else

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;
	uint batchStart = QueueState[QUEUE_STATE_INDEX].nodeReadOffset + groupID * BVH_MAX_GROUP_BATCH_SIZE;
	uint batchSize = min(batchStart + BVH_MAX_GROUP_BATCH_SIZE, QueueState[QUEUE_STATE_INDEX].nodePrevWriteOffset) - batchStart;

	uint batchIndex = batchStart + groupIndex;
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
	batchIndex += MAX_CANDIDATE_NODE;
#endif

#if DONT_USE_SHARED_NODE_BATCH == 0
	if (groupIndex < batchSize)
	{
		SharedCandidateNodeBatch[groupIndex] = CandidateNodeBatch[batchIndex];
	}
	barrier();
#endif
	ProcessNodeBatch(groupIndex, batchStart, batchSize);
	if (groupIndex < batchSize)
	{
		CandidateNodeBatch[batchIndex] = uvec4(0xFFFFFFFF);
	}
}

#endif