#include "vg_define.h"
#include "culling.h"
#include "wave.h"

shared uvec4 SharedCandidateNodeBatch[BVH_MAX_GROUP_BATCH_SIZE];

#define DEBUG_SHADER_GROUP 0
#define EMIT_CLUSTER_EACH_THREAD 1

bool IsSharedHierarchyDataValid(uint index)
{
	return SharedCandidateNodeBatch[index].x != 0xFFFFFFFF;
}

void ProcessNodeBatch(uint groupIndex, uint batchStart, uint batchSize)
{
	uint localIndex = groupIndex / BVH_MAX_NODES;
	uint childIndex = groupIndex & BVH_NODE_MASK;

	uint batchIndex = batchStart + localIndex;
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
	batchIndex += MAX_CANDIDATE_NODE;
#endif
#if DEBUG_SHADER_GROUP
	if (localIndex >= batchSize)
	{
		return;
	}
	CandidateNode nodeBatch = UnpackCandidateNode(CandidateNodeBatch[batchIndex]);
#else
	if (!IsSharedHierarchyDataValid(localIndex))
	{
		return;
	}
	CandidateNode nodeBatch = UnpackCandidateNode(SharedCandidateNodeBatch[localIndex]);
#endif

	uint instanceId = nodeBatch.instanceId;
	uint resourceIndex = InstanceData[instanceId].resourceIndex;

	ClusterHierarchyStruct hierarchy;
	GetHierarchyData(nodeBatch, hierarchy);

	uint isLeaf = hierarchy.isLeaf;

	mat4 localToWorld = InstanceData[instanceId].transform;

	vec3 boundCenter = hierarchy.lodBoundCenterError.xyz;
	float maxParentError = hierarchy.lodBoundCenterError.w;
	vec3 boundHalfExtend = hierarchy.lodBoundHalfExtendRadius.xyz;
	float radius = hierarchy.lodBoundHalfExtendRadius.w;

	FrustumCullData cullData = BoxCullFrustumGeneral(boundCenter, boundHalfExtend, localToWorld, worldToClip, true, false);

#if CULL_CLUSTER_ALONG_BVH
	if (cullData.bIsVisible)
	{
#if USE_INSTANCE_CENTER_CULL
		cullData.bIsVisible = ShouldVisitChild(localToWorld, worldToView, vec3(0, 0, 0), radius, maxParentError);
#else
		cullData.bIsVisible = ShouldVisitChild(localToWorld, worldToView, boundCenter, radius, maxParentError);
#endif
	}
#endif

#if INSTANCE_CULL_MODE == INSTANCE_CULL_MAIN || INSTANCE_CULL_MODE == INSTANCE_CULL_POST
	if (cullData.bIsVisible)
	{
		ivec2 hzbSize = textureSize(hiZTex, 0);
		ScreenRect rect = GetScreenRect(ivec4(0, 0, hzbSize * 2), cullData, 4);
		cullData.bIsVisible = IsVisibleHZB(rect, hzbSize, true);
	}
#if INSTANCE_CULL_MODE == INSTANCE_CULL_MAIN
	if (!cullData.bIsVisible)
	{
		uint nodeWriteOffset = 0;
		WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_POST_INDEX].nodeWriteOffset, 1, nodeWriteOffset);
		if (nodeWriteOffset < MAX_CANDIDATE_NODE)
		{
			nodeWriteOffset += MAX_CANDIDATE_NODE;
			CandidateNode node;
			node.instanceId = nodeBatch.instanceId;
			node.nodeIndex = nodeBatch.nodeIndex;
			StoreCandidateNode(nodeWriteOffset, node);
		}
	}
#endif
#endif

	if (!cullData.bIsVisible)
	{
		return;
	}

	if (isLeaf == 0)
	{
		uint nodeIndex = hierarchy.children[childIndex];
		if (nodeIndex != INVALID_INDEX)
		{
			uint nodeWriteOffset = 0;
			WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_INDEX].nodeWriteOffset, 1, nodeWriteOffset);
			if (nodeWriteOffset < MAX_CANDIDATE_NODE)
			{
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
				nodeWriteOffset += MAX_CANDIDATE_NODE;
#endif
				CandidateNode node;
				node.instanceId = instanceId;
				node.nodeIndex = nodeIndex;
				StoreCandidateNode(nodeWriteOffset, node);
				// ExtraDebugInfo[nodeWriteOffset] = groupIndex; //uint(IsSharedHierarchyDataValid(localIndex));
			}
		}
	}
	// Leaf
	else
	{
#if EMIT_CLUSTER_EACH_THREAD
		uint clusterNumPerChild = hierarchy.clusterNum / BVH_MAX_NODES;
		uint clusterNumPerChildRest = hierarchy.clusterNum & BVH_NODE_MASK;

		uint clusterStart = hierarchy.clusterStart + childIndex * clusterNumPerChild + uint(childIndex != 0) * clusterNumPerChildRest;
		uint clusterNum = clusterNumPerChild + uint(childIndex == 0) * clusterNumPerChildRest;
		if (clusterNum == 0)
		{
			return;
		}
#else
		if (childIndex != 0)
		{
			return;
		}
		uint clusterStart = hierarchy.clusterStart;
		uint clusterNum = hierarchy.clusterNum;
#endif
		uint clusterWriteOffset = 0;
		WAVE_INTERLOCK_ADD(QueueState[QUEUE_STATE_INDEX].clusterWriteOffset, clusterNum, clusterWriteOffset);

		for (uint i = 0; i < clusterNum; ++i)
		{
			if (clusterWriteOffset + i >= MAX_CANDIDATE_CLUSTER)
			{
				break;
			}
			CandidateCluster candidateCluster;
			candidateCluster.instanceId = instanceId;
			candidateCluster.clusterIndex = clusterStart + i;
			StoreCandidateCluster(clusterWriteOffset + i, candidateCluster);
		}
	}
}

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;
	uint maxBatchNodes = QueueState[QUEUE_STATE_INDEX].nodePrevWriteOffset - QueueState[QUEUE_STATE_INDEX].nodeReadOffset;

	uint batchStart = QueueState[QUEUE_STATE_INDEX].nodeReadOffset + groupID * BVH_MAX_GROUP_BATCH_SIZE;
	uint batchSize = min(batchStart + BVH_MAX_GROUP_BATCH_SIZE, QueueState[QUEUE_STATE_INDEX].nodePrevWriteOffset) - batchStart;

	uint localIndex = groupIndex / BVH_MAX_NODES;
	uint childIndex = groupIndex & BVH_NODE_MASK;

	uint batchIndex = batchStart + localIndex;
#if INSTANCE_CULL_MODE == INSTANCE_CULL_POST
	batchIndex += MAX_CANDIDATE_NODE;
#endif

#if !DEBUG_SHADER_GROUP
	if (childIndex == 0)
	{
		if (localIndex < batchSize)
		{
			SharedCandidateNodeBatch[localIndex] = CandidateNodeBatch[batchIndex];
		}
		else
		{
			SharedCandidateNodeBatch[localIndex] = uvec4(0xFFFFFFFF);
		}
	}
	memoryBarrierShared(); // barrier();
#endif

	ProcessNodeBatch(groupIndex, batchStart, batchSize);

#if !DEBUG_SHADER_GROUP
	if (IsSharedHierarchyDataValid(localIndex))
	{
		CandidateNodeBatch[batchIndex] = uvec4(0xFFFFFFFF);
	}
#endif
}