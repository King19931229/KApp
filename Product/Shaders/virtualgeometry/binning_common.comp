#include "vg_define.h"
#include "culling.h"
#include "wave.h"

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;

	uint batchStart = groupID * VG_GROUP_SIZE;
	uint batchSize = min(batchStart + VG_GROUP_SIZE, QueueState[0].visibleClusterNum) - batchStart;

	if (groupIndex < batchSize)
	{
		uint clusterIndex = batchStart + groupIndex;

		CandidateCluster selectedCluster = UnpackCandidateCluster(SelectedClusterBatch[clusterIndex]);
		uint instanceId = selectedCluster.instanceId;

		ClusterBatchStruct clusterBatch;
		GetClusterData(selectedCluster, clusterBatch);

		uint resourceIndex = InstanceData[instanceId].resourceIndex;

		uint materialNum = clusterBatch.materialNum;
		for (uint i = 0; i < materialNum; i++)
		{
			uint materialIndex = 0;
			uint rangeBegin = 0;
			uint rangeEnd = 0;
			GetMaterialIndexAndRange(resourceIndex, i, clusterBatch, materialIndex, rangeBegin, rangeEnd);

			uint binningIndex = InstanceData[instanceId].binningBaseIndex + materialIndex;
#if defined(BINNING_CLASSIFY)
			WAVE_INTERLOCK_ADD_ONLY(BinningHeader[binningIndex].x, 1);
#elif defined(BINNING_SCATTER)
			BinningBatch batch;
			batch.clusterIndex = clusterIndex;
			batch.binningIndex = binningIndex;
			batch.rangeBegin = rangeBegin;
			batch.rangeNum = rangeEnd - rangeBegin + 1;

			uint offset = 0;

			offset = binningIndex * 4;
			offset += INDIRECT_DRAW_ARGS_OFFSET;

			uint batchOffset = 0;
			WAVE_INTERLOCK_ADD(IndirectDrawArgs[offset + 1], 1, batchOffset);
			uint binningWriteOffset = BinningHeader[binningIndex].y + batchOffset;

			StoreBinningBatch(binningWriteOffset, batch);

			offset = binningIndex * 3;
			offset += INDIRECT_MESH_ARGS_OFFSET;
			WAVE_INTERLOCK_ADD_ONLY(IndirectMeshArgs[offset], 1);
#endif
		}
	}
}