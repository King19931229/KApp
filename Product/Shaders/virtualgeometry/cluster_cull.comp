#include "vg_define.h"
#include "culling.h"

void ProcessClusterBatch(uint groupIndex, uint batchStart, uint batchSize)
{
    uint batchIndex = batchStart + groupIndex;

	if (CandidateClusterBatch[batchIndex] != 0xFFFFFFFF)
	{
		CandidateCluster candidateCluster = UnpackCandidateCluster(CandidateClusterBatch[batchIndex]);
		uint instanceId = candidateCluster.instanceId;

		ClusterBatchStruct clusterBatch;
		GetClusterData(candidateCluster, clusterBatch);

		mat4 localToWorld = InstanceData[instanceId].transform;

		vec3 boundCenter = clusterBatch.lodBoundCenterError.xyz;
		float localError = clusterBatch.lodBoundCenterError.w;
		vec3 boundHalfExtend = clusterBatch.lodBoundHalfExtendRadius.xyz;
		float boundRadius = clusterBatch.lodBoundHalfExtendRadius.w;

		FrustumCullData cullData = BoxCullFrustumGeneral(boundCenter.xyz, boundHalfExtend.xyz, localToWorld, worldToClip, true, false);
#if CULL_CLUSTER_ALONG_BVH
		if (cullData.bIsVisible)
		{
			cullData.bIsVisible = SmallEnoughToDraw(localToWorld, worldToView, boundCenter.xyz, boundRadius, localError);
		}
#else
		if (cullData.bIsVisible)
		{
			float parentError = clusterBatch.parentBoundCenterError.w;
			cullData.bIsVisible = FitToDraw(localToWorld, worldToView, boundCenter.xyz, boundRadius, localError, parentError);
		}
#endif
		if (cullData.bIsVisible)
		{
			uint clusterWriteOffset = InterlockAddSelectedClusterWriteOffset(1);
			if (clusterWriteOffset < MAX_CANDIDATE_CLUSTER)
			{
				StoreSelectedCluster(clusterWriteOffset, candidateCluster);
				ExtraDebugInfo[clusterWriteOffset] = GetProjectScale(localToWorld, worldToView, boundCenter, boundRadius).x;
			}
		}

		CandidateClusterBatch[batchIndex] = 0xFFFFFFFF;
	}
}

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;

	uint batchStart = QueueState[0].clusterReadOffset + groupID * VG_GROUP_SIZE;
	uint batchSize = min(batchStart + VG_GROUP_SIZE, QueueState[0].clusterWriteOffset) - batchStart;

	if (groupIndex < batchSize)
	{
		ProcessClusterBatch(groupIndex, batchStart, batchSize);
	}
}