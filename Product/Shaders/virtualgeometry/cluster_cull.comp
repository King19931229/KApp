#include "vg_default_binding.h"
#include "vg_define.h"
#include "culling.h"

void ProcessClusterBatch(uint groupIndex, uint batchStart, uint batchSize)
{
    uint batchIndex = batchStart + groupIndex;

	if (CandidateClusterBatch[batchIndex].x != 0xFFFFFFFF)
	{
		CandidateCluster candidateCluster = UnpackCandidateCluster(CandidateClusterBatch[batchIndex]);
		uint instanceId = candidateCluster.instanceId;

		ClusterBatchStruct clusterBatch;
		GetClusterData(candidateCluster, clusterBatch);

		mat4 localToWorld = InstanceData[instanceId].transform;

		vec3 boundCenter = clusterBatch.lodBoundCenterError.xyz;
		float localError = clusterBatch.lodBoundCenterError.w;
		vec3 boundHalfExtend = clusterBatch.lodBoundHalfExtendRadius.xyz;
		float boundRadius = clusterBatch.lodBoundHalfExtendRadius.w;

		FrustumCullData cullData = BoxCullFrustumGeneral(boundCenter, boundHalfExtend, localToWorld, worldToClip, true, false);

		vec3 instanceCenter = vec3(localToWorld[3][0], localToWorld[3][1], localToWorld[3][2]);
#if CULL_CLUSTER_ALONG_BVH
		if (cullData.bIsVisible)
		{
#if USE_INSTANCE_CENTER_CULL
			cullData.bIsVisible = SmallEnoughToDraw(localToWorld, worldToView, instanceCenter, boundRadius, localError);
#else
			cullData.bIsVisible = SmallEnoughToDraw(localToWorld, worldToView, boundCenter, boundRadius, localError);
#endif
		}
#else
		if (cullData.bIsVisible)
		{
			vec3 parentBoundCenter = clusterBatch.parentBoundCenterError.xyz;
			float parentError = clusterBatch.parentBoundCenterError.w;
			float parentBoundRadius = clusterBatch.parentBoundHalfExtendRadius.w;
#if USE_INSTANCE_CENTER_CULL
			cullData.bIsVisible = FitToDraw(localToWorld, worldToView, instanceCenter, boundRadius, localError, instanceCenter, parentBoundRadius, parentError);
#else
			cullData.bIsVisible = FitToDraw(localToWorld, worldToView, boundCenter, boundRadius, localError, parentBoundCenter, parentBoundRadius, parentError);
#endif
		}
#endif
		if (cullData.bIsVisible)
		{
			uint clusterWriteOffset = atomicAdd(QueueState[0].visibleClusterNum, 1);
			if (clusterWriteOffset < MAX_CANDIDATE_CLUSTER)
			{
				StoreSelectedCluster(clusterWriteOffset, candidateCluster);
				ExtraDebugInfo[clusterWriteOffset] = GetProjectScale(localToWorld, worldToView, boundCenter, boundRadius).x;
			}
		}

		CandidateClusterBatch[batchIndex] = uvec4(0xFFFFFFFF);
	}
}

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;

	uint batchStart = QueueState[0].clusterReadOffset + groupID * VG_GROUP_SIZE;
	uint batchSize = min(batchStart + VG_GROUP_SIZE, QueueState[0].clusterWriteOffset) - batchStart;

	if (groupIndex < batchSize)
	{
		ProcessClusterBatch(groupIndex, batchStart, batchSize);
	}
}