#include "vg_define.h"
#include "culling.h"

void ProcessClusterBatch(uint groupIndex, uint batchStart, uint batchSize)
{
    uint batchIndex = batchStart + groupIndex;
	CandidateCluster candidateCluster = UnpackCandidateCluster(CandidateClusterBatch[batchIndex]);
	if (candidateCluster.clusterIndex != INVALID_INDEX)
	{
		uint instanceId = candidateCluster.instanceId;
		uint clusterWriteOffset = InterlockAddClusterWriteOffset(1);
		if (clusterWriteOffset < MAX_CANDIDATE_CLUSTER)
		{
			ClusterBatchStruct clusterBatch;
			GetClusterData(candidateCluster, clusterBatch);

			mat4 localToWorld = InstanceData[instanceId].transform;

			vec3 boundCenter = clusterBatch.lodBoundCenterError.xyz;
			float localError = clusterBatch.lodBoundCenterError.w;
			vec3 boundHalfExtend = clusterBatch.lodBoundHalfExtendRadius.xyz;
			float radius = clusterBatch.lodBoundHalfExtendRadius.w;

			float maxParentError = clusterBatch.parentBoundCenterError.w;

			FrustumCullData cullData = BoxCullFrustumGeneral(boundCenter.xyz, boundHalfExtend.xyz, localToWorld, worldToClip, true, false);
#if CULL_CLUSTER_ALONG_BVH
			if (cullData.bIsVisible)
			{
				cullData.bIsVisible = SmallEnoughToDraw(localToWorld, worldToView, boundCenter.xyz, radius, maxParentError);
			}
#else
			cullData.bIsVisible = false;
#endif
			if (cullData.bIsVisible)
			{
				StoreSelectedCluster(clusterWriteOffset, candidateCluster);
			}
		}
		CandidateClusterBatch[batchIndex] = 0xFFFFFFFF;
		ExtraDebugInfo[batchIndex] = groupIndex;
	}
}

layout(local_size_x = VG_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint groupID = gl_WorkGroupID.x;
	uint groupIndex = gl_LocalInvocationID.x;
	uint maxBatchClusters = QueueState[0].clusterWriteOffset - QueueState[0].clusterReadOffset;

	uint batchStart = groupID * VG_GROUP_SIZE;
	uint batchSize = min(batchStart + VG_GROUP_SIZE, maxBatchClusters) - batchStart;

	if (groupIndex < batchSize)
	{
		ProcessClusterBatch(groupIndex, batchStart, batchSize);
	}
}