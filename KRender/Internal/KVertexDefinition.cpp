#include "KVertexDefinition.h"
#include "KBase/Publish/Mesh/KVirtualGeometryBuilder.h"

#include <algorithm>

namespace KVertexDefinition
{
	static VertexDetail VERTEX_DETAILS[VF_COUNT];

	static bool VERTEX_DETAIL_INIT = false;

	void EnsureInit()
	{
		if (!VERTEX_DETAIL_INIT)
		{
			// POS_3F_NORM_3F_UV_2F
			{
				VERTEX_DETAILS[VF_POINT_NORMAL_UV].semanticDetails.push_back({ VS_POSITION, EF_R32G32B32_FLOAT, MEMBER_OFFSET(POS_3F_NORM_3F_UV_2F, POSITION) });
				VERTEX_DETAILS[VF_POINT_NORMAL_UV].semanticDetails.push_back({ VS_NORMAL, EF_R32G32B32_FLOAT, MEMBER_OFFSET(POS_3F_NORM_3F_UV_2F, NORMAL) });
				VERTEX_DETAILS[VF_POINT_NORMAL_UV].semanticDetails.push_back({ VS_TEXCOORD0, EF_R32G32_FLOAT, MEMBER_OFFSET(POS_3F_NORM_3F_UV_2F, UV) });
				VERTEX_DETAILS[VF_POINT_NORMAL_UV].vertexSize = sizeof(POS_3F_NORM_3F_UV_2F);
			}
			// UV2_2F
			{
				VERTEX_DETAILS[VF_UV2].semanticDetails.push_back({ VS_TEXCOORD1, EF_R32G32_FLOAT, MEMBER_OFFSET(UV2_2F, UV2) });
				VERTEX_DETAILS[VF_UV2].vertexSize = sizeof(UV2_2F);
			}
			// COLOR_3F
			{
				for (uint32_t i = 0; i < VF_MAX_VERTEX_COUNT; ++i)
				{
					VERTEX_DETAILS[VF_COLOR0 + i].semanticDetails.push_back({ (VertexSemantic)(VS_COLOR0 + i), EF_R32G32B32_FLOAT, MEMBER_OFFSET(COLOR_3F, COLOR) });
					VERTEX_DETAILS[VF_COLOR0 + i].vertexSize = sizeof(COLOR_3F);
				}
			}
			// TAN_3F_BIN_3F
			{
				VERTEX_DETAILS[VF_TANGENT_BINORMAL].semanticDetails.push_back({ VS_TANGENT, EF_R32G32B32_FLOAT, MEMBER_OFFSET(TAN_3F_BIN_3F, TANGENT) });
				VERTEX_DETAILS[VF_TANGENT_BINORMAL].semanticDetails.push_back({ VS_BINORMAL, EF_R32G32B32_FLOAT, MEMBER_OFFSET(TAN_3F_BIN_3F, BINORMAL) });
				VERTEX_DETAILS[VF_TANGENT_BINORMAL].vertexSize = sizeof(TAN_3F_BIN_3F);
			}
			// BW_4F_BI_4I
			{
				VERTEX_DETAILS[VF_BLEND_WEIGHTS_INDICES].semanticDetails.push_back({ VS_BLEND_WEIGHTS, EF_R32_FLOAT, MEMBER_OFFSET(BW_4F_BI_4I, BLEND_WEIGHTS) });
				VERTEX_DETAILS[VF_BLEND_WEIGHTS_INDICES].semanticDetails.push_back({ VS_BLEND_INDICES, EF_R32_UINT, MEMBER_OFFSET(BW_4F_BI_4I, BLEND_INDICES) });
				VERTEX_DETAILS[VF_BLEND_WEIGHTS_INDICES].vertexSize = sizeof(BW_4F_BI_4I);
			}
			// GUI_POS_2F_UV_2F_COLOR_4BYTE
			{
				VERTEX_DETAILS[VF_GUI_POS_UV_COLOR].semanticDetails.push_back({ VS_GUI_POS, EF_R32G32_FLOAT, MEMBER_OFFSET(GUI_POS_2F_UV_2F_COLOR_4BYTE, GUI_POSITION) });
				VERTEX_DETAILS[VF_GUI_POS_UV_COLOR].semanticDetails.push_back({ VS_GUI_UV, EF_R32G32_FLOAT, MEMBER_OFFSET(GUI_POS_2F_UV_2F_COLOR_4BYTE, GUI_UV) });
				VERTEX_DETAILS[VF_GUI_POS_UV_COLOR].semanticDetails.push_back({ VS_GUI_COLOR, EF_R8G8B8A8_UNORM, MEMBER_OFFSET(GUI_POS_2F_UV_2F_COLOR_4BYTE, GUI_COLOR) });
				VERTEX_DETAILS[VF_GUI_POS_UV_COLOR].vertexSize = sizeof(GUI_POS_2F_UV_2F_COLOR_4BYTE);
			}
			// SCREENQUAD_POS_2F
			{
				VERTEX_DETAILS[VF_SCREENQUAD_POS].semanticDetails.push_back({ VS_SCREENQAUD_POS, EF_R32G32_FLOAT, MEMBER_OFFSET(SCREENQUAD_POS_2F, QUAD_POSITION) });
				VERTEX_DETAILS[VF_SCREENQUAD_POS].vertexSize = sizeof(SCREENQUAD_POS_2F);
			}
			// DEBUG_POS_3F
			{
				VERTEX_DETAILS[VF_DEBUG_POINT].semanticDetails.push_back({ VS_POSITION, EF_R32G32B32_FLOAT, MEMBER_OFFSET(DEBUG_POS_3F, DEBUG_POSITION) });
				VERTEX_DETAILS[VF_DEBUG_POINT].vertexSize = sizeof(DEBUG_POS_3F);
			}
			// INSTANCE_DATA_MATRIX4F
			{
				VERTEX_DETAILS[VF_INSTANCE].semanticDetails.push_back({ VS_INSTANCE_ROW_0, EF_R32G32B32A32_FLOAT, MEMBER_OFFSET(INSTANCE_DATA_MATRIX4F, ROW0) });
				VERTEX_DETAILS[VF_INSTANCE].semanticDetails.push_back({ VS_INSTANCE_ROW_1, EF_R32G32B32A32_FLOAT, MEMBER_OFFSET(INSTANCE_DATA_MATRIX4F, ROW1) });
				VERTEX_DETAILS[VF_INSTANCE].semanticDetails.push_back({ VS_INSTANCE_ROW_2, EF_R32G32B32A32_FLOAT, MEMBER_OFFSET(INSTANCE_DATA_MATRIX4F, ROW2) });
				VERTEX_DETAILS[VF_INSTANCE].semanticDetails.push_back({ VS_INSTANCE_PREV_ROW_0, EF_R32G32B32A32_FLOAT, MEMBER_OFFSET(INSTANCE_DATA_MATRIX4F, PREV_ROW0) });
				VERTEX_DETAILS[VF_INSTANCE].semanticDetails.push_back({ VS_INSTANCE_PREV_ROW_1, EF_R32G32B32A32_FLOAT, MEMBER_OFFSET(INSTANCE_DATA_MATRIX4F, PREV_ROW1) });
				VERTEX_DETAILS[VF_INSTANCE].semanticDetails.push_back({ VS_INSTANCE_PREV_ROW_2, EF_R32G32B32A32_FLOAT, MEMBER_OFFSET(INSTANCE_DATA_MATRIX4F, PREV_ROW2) });
				VERTEX_DETAILS[VF_INSTANCE].vertexSize = sizeof(INSTANCE_DATA_MATRIX4F);
			}
			// TERRAIN_POS_2F
			{
				VERTEX_DETAILS[VF_TERRAIN_POS].semanticDetails.push_back({ VS_TERRAIN_POS, EF_R32G32_FLOAT, MEMBER_OFFSET(TERRAIN_POS_2F, POS) });
				VERTEX_DETAILS[VF_TERRAIN_POS].vertexSize = sizeof(TERRAIN_POS_2F);
			}
			// VIRTUAL_GEOMERTY_VERTEX_POS_3F_NORM_3F_UV_2F
			{
				VERTEX_DETAILS[VF_VIRTUAL_GEOMETRY_VERTEX].semanticDetails.push_back({ VS_POSITION, EF_R32G32B32_FLOAT, MEMBER_OFFSET(VIRTUAL_GEOMERTY_VERTEX_POS_3F_NORM_3F_UV_2F, POSITION) });
				VERTEX_DETAILS[VF_VIRTUAL_GEOMETRY_VERTEX].semanticDetails.push_back({ VS_NORMAL, EF_R32G32B32_FLOAT, MEMBER_OFFSET(VIRTUAL_GEOMERTY_VERTEX_POS_3F_NORM_3F_UV_2F, NORMAL) });
				VERTEX_DETAILS[VF_VIRTUAL_GEOMETRY_VERTEX].semanticDetails.push_back({ VS_TEXCOORD0, EF_R32G32_FLOAT, MEMBER_OFFSET(VIRTUAL_GEOMERTY_VERTEX_POS_3F_NORM_3F_UV_2F, UV) });
				VERTEX_DETAILS[VF_VIRTUAL_GEOMETRY_VERTEX].vertexSize = sizeof(VIRTUAL_GEOMERTY_VERTEX_POS_3F_NORM_3F_UV_2F);
				static_assert(sizeof(VIRTUAL_GEOMERTY_VERTEX_POS_3F_NORM_3F_UV_2F) == KVirtualGeometryEncoding::FLOAT_PER_VERTEX * sizeof(float), "must match");
			}
			VERTEX_DETAIL_INIT = true;
		}
	}

	const VertexDetail& GetVertexDetail(VertexFormat format)
	{
		EnsureInit();
		assert(VERTEX_DETAILS[format].vertexSize > 0);
		return VERTEX_DETAILS[format];
	}
}