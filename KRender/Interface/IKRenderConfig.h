#pragma once
#include "KBase/Publish/KConfig.h"

#include <vector>
#include <memory>

enum RenderDevice
{
	RENDER_DEVICE_VULKAN
};

enum ShaderType
{
	// Tradition
	ST_VERTEX = 1 << 0,
	ST_FRAGMENT = 1 << 1,
	ST_GEOMETRY = 1 << 2,

	// RayTracing
	ST_RAYGEN = 1 << 3,
	ST_ANY_HIT = 1 << 4,
	ST_CLOSEST_HIT = 1 << 5,
	ST_MISS = 1 << 6,

	// Compute
	ST_COMPUTE = 1 << 7,

	// Mesh
	ST_TASK = 1 << 8,
	ST_MESH = 1 << 9,

	ST_ENDENUM
};
typedef unsigned short ShaderTypes;

enum VertexSemantic
{
	#define VERTEX_SEMANTIC(SEMANTIC, LOCATION) VS_##SEMANTIC = LOCATION,
	#include "KVertexSemantic.inl"
	#undef VERTEX_SEMANTIC
};

enum ShaderBinding
{
	#define CONSTANT_BUFFER_BINDING(CONSTANT)	SHADER_BINDING_##CONSTANT,
	#define STORAGE_BUFFER_BINDING(STORAGE)		SHADER_BINDING_##STORAGE,
	#define TEXTURE_BINDING(SLOT)				SHADER_BINDING_TEXTURE##SLOT,
	#include "KShaderBinding.inl"
	#undef TEXTURE_BINDING
	#undef STORAGE_BUFFER_BINDING
	#undef CONSTANT_BUFFER_BINDING
};

enum ConstantBufferType
{
	#define CONSTANT_BUFFER_BINDING(CONSTANT) CBT_##CONSTANT = SHADER_BINDING_##CONSTANT,
	#define STORAGE_BUFFER_BINDING(...)
	#define TEXTURE_BINDING(...)
	#include "KShaderBinding.inl"
	#undef TEXTURE_BINDING
	#undef STORAGE_BUFFER_BINDING
	#undef CONSTANT_BUFFER_BINDING
};

enum StorageBufferType
{
	#define CONSTANT_BUFFER_BINDING(...)
	#define STORAGE_BUFFER_BINDING(STORAGE)  SBT_##STORAGE = SHADER_BINDING_##STORAGE,
	#define TEXTURE_BINDING(...)
	#include "KShaderBinding.inl"
	#undef TEXTURE_BINDING
	#undef STORAGE_BUFFER_BINDING
	#undef CONSTANT_BUFFER_BINDING
};

enum
{
	CBT_STATIC_BEGIN = CBT_CAMERA,
	CBT_STATIC_END = CBT_VIRTUAL_TEXTURE_CONSTANT,

	CBT_DYNAMIC_BEGIN = CBT_OBJECT,
	CBT_DYNAMIC_END = CBT_DEBUG,

	CBT_BEGIN = CBT_STATIC_BEGIN,
	CBT_END = CBT_DYNAMIC_END,

	CBT_STATIC_COUNT = CBT_STATIC_END - CBT_STATIC_BEGIN + 1,
	CBT_DYNAMIC_COUNT = CBT_DYNAMIC_END - CBT_DYNAMIC_BEGIN + 1,

	CBT_COUNT = CBT_DYNAMIC_COUNT + CBT_STATIC_COUNT
};
static_assert(CBT_END + 1 == SBT_POINT_NORMAL_UV, "Code miss match");

enum
{
	SBT_BEGIN = SBT_POINT_NORMAL_UV,
	SBT_END = SBT_DRAWING_GROUP,
	SBT_COUNT = SBT_END - SBT_BEGIN + 1
};
static_assert(SBT_END + 1 == SHADER_BINDING_TEXTURE0, "Code miss match");

enum
{
	TB_BEGIN = SBT_END + 1
};

#define DYNAMIC_UNIFORM_BUFFER_SUFFIX "_DYN_UNIFORM"

struct KConstantBufferTypeDescription
{
	ConstantBufferType type;
	const char* debugName;
};

enum RayTraceBinding
{
	RAYTRACE_BINDING_AS,
	RAYTRACE_BINDING_IMAGE,
	RAYTRACE_BINDING_CAMERA,
	RAYTRACE_BINDING_SCENE,
	RAYTRACE_BINDING_TEXTURES,
	RAYTRACE_BINDING_GBUFFER0,
	RAYTRACE_BINDING_GBUFFER1
};

enum ConstantSemantic
{
	CS_VIEW,
	CS_PROJ,
	CS_VIEW_INV,
	CS_PROJ_INV,
	CS_VIEW_PROJ,
	CS_PREV_VIEW_PROJ,
	CS_CAMERA_PARAMETERS,
	CS_FRUSTUM_PLANES,

	CS_SHADOW_VIEW,
	CS_SHADOW_PROJ,
	CS_SHADOW_CAMERA_PARAMETERS,

	CS_CASCADED_SHADOW_VIEW,
	CS_CASCADED_SHADOW_VIEW_PROJ,
	CS_CASCADED_SHADOW_LIGHT_INFO,

	CS_CASCADED_SHADOW_SPLIT,
	CS_CASCADED_SHADOW_FRUSTUM_PLANES,
	CS_CASCADED_SHADOW_CENTER,
	CS_CASCADED_SHADOW_NUM_CASCADED,

	CS_VOXEL_VIEW_PROJ,
	CS_VOXEL_VIEW_PROJ_INV,
	CS_VOXEL_MINPOINT_SCALE,
	CS_VOXEL_MAXPOINT_SCALE,
	CS_VOXEL_MISCS,
	CS_VOXEL_MISCS2,
	CS_VOXEL_MISCS3,

	CS_VOXEL_CLIPMAP_VIEW_PROJ,
	CS_VOXEL_CLIPMAP_VIEW_PROJ_INV,
	CS_VOXEL_CLIPMAP_UPDATE_REGION_MIN,
	CS_VOXEL_CLIPMAP_UPDATE_REGION_MAX,
	CS_VOXEL_CLIPMAP_REIGION_MIN_AND_VOXELSIZE,
	CS_VOXEL_CLIPMAP_REIGION_MAX_AND_EXTENT,
	CS_VOXEL_CLIPMAP_MISCS,
	CS_VOXEL_CLIPMAP_MISCS2,
	CS_VOXEL_CLIPMAP_MISCS3,
	CS_VOXEL_CLIPMAP_MISCS4,

	CS_GLOBAL_SUN_LIGHT_DIRECTION_AND_PBR_MAX_REFLECTION_LOD,

	CS_VIRTUAL_TEXTURE_DESCRIPTION,
	CS_VIRTUAL_TEXTURE_DESCRIPTION2
};

enum VertexFormat
{
	#define VERTEX_FORMAT_SCENE(FORMAT) VF_##FORMAT,
	#define VERTEX_FORMAT_OTHER(FORMAT) VF_##FORMAT,
	#include "KVertexFormat.inl"
	#undef VERTEX_FORMAT_OTHER
	#undef VERTEX_FORMAT_SCENE
	VF_UNKNOWN,
	VF_COUNT = VF_UNKNOWN,
	VF_SCENE_COUNT = VF_GUI_POS_UV_COLOR,
	VF_MAX_VERTEX_COUNT = VF_COLOR5 - VF_COLOR0 + 1
};

static_assert(VF_COLOR0 + VF_MAX_VERTEX_COUNT == VF_GUI_POS_UV_COLOR, "check");

enum ElementFormat
{
	EF_R8G8B8A8_UNORM,
	EF_R8G8B8A8_SNORM,

	EF_R4G4B4A4_UNORM,
	EF_R5G5B5A1_UNORM,

	EF_R8G8B8_UNORM,
	EF_R8G8_UNORM,
	EF_R8_UNORM,

	EF_R16_FLOAT,
	EF_R16G16_FLOAT,
	EF_R16G16B16_FLOAT,
	EF_R16G16B16A16_FLOAT,

	EF_R32_FLOAT,
	EF_R32G32_FLOAT,
	EF_R32G32B32_FLOAT,
	EF_R32G32B32A32_FLOAT,

	EF_R16_UINT,
	EF_R32_UINT,
	EF_R32G32B32A32_UINT,

	EF_R32_INT,
	EF_R32G32B32A32_INT,

	EF_ETC1_R8G8B8_UNORM,
	EF_ETC2_R8G8B8_UNORM,
	EF_ETC2_R8G8B8A1_UNORM,
	EF_ETC2_R8G8B8A8_UNORM,

	EF_BC1_RGB_UNORM,
	EF_BC1_RGB_SRGB,
	EF_BC1_RGBA_UNORM,
	EF_BC1_RGBA_SRGB,
	EF_BC2_UNORM,
	EF_BC2_SRGB,
	EF_BC3_UNORM,
	EF_BC3_SRGB,
	EF_BC4_UNORM,
	EF_BC4_SNORM,
	EF_BC5_UNORM,
	EF_BC5_SNORM,
	EF_BC6H_UFLOAT,
	EF_BC6H_SFLOAT,
	EF_BC7_UNORM,
	EF_BC7_SRGB,

	EF_ASTC_4x4_UNORM,
	EF_ASTC_4x4_SRGB,
	EF_ASTC_5x4_UNORM,
	EF_ASTC_5x4_SRGB,
	EF_ASTC_5x5_UNORM,
	EF_ASTC_5x5_SRGB,
	EF_ASTC_6x5_UNORM,
	EF_ASTC_6x5_SRGB,
	EF_ASTC_6x6_UNORM,
	EF_ASTC_6x6_SRGB,
	EF_ASTC_8x5_UNORM,
	EF_ASTC_8x5_SRGB,
	EF_ASTC_8x6_UNORM,
	EF_ASTC_8x6_SRGB,
	EF_ASTC_8x8_UNORM,
	EF_ASTC_8x8_SRGB,
	EF_ASTC_10x5_UNORM,
	EF_ASTC_10x5_SRGB,
	EF_ASTC_10x6_UNORM,
	EF_ASTC_10x6_SRGB,
	EF_ASTC_10x8_UNORM,
	EF_ASTC_10x8_SRGB,
	EF_ASTC_10x10_UNORM,
	EF_ASTC_10x10_SRGB,
	EF_ASTC_12x10_UNORM,
	EF_ASTC_12x10_SRGB,
	EF_ASTC_12x12_UNORM,
	EF_ASTC_12x12_SRGB,

	EF_UNKNOWN,
	EF_COUNT = EF_UNKNOWN
};

enum IndexType
{
	IT_16,
	IT_32
};

enum TextureType
{
	TT_TEXTURE_2D,
	TT_TEXTURE_3D,
	TT_TEXTURE_CUBE_MAP,

	TT_TEXTURE_2D_ARRAY,

	TT_UNKNOWN,
	TT_COUNT = TT_UNKNOWN
};

enum AddressMode
{
	AM_REPEAT,
	AM_CLAMP_TO_EDGE,
	AM_MIRROR_CLAMP_TO_EDGE,
	// AM_CLAMP_TO_BORDER,
	// AM_MIRROR_CLAMP_TO_BORDER,
	AM_UNKNOWN,
	AM_COUNT = AM_UNKNOWN
};

enum FilterMode
{
	FM_NEAREST,
	FM_LINEAR,

	FM_UNKNOWN,
	FM_COUNT = FM_UNKNOWN
};

enum PrimitiveTopology
{
	PT_POINT_LIST,
	PT_TRIANGLE_LIST,
	PT_TRIANGLE_STRIP,
	PT_LINE_LIST,
	PT_LINE_STRIP
};

enum PolygonMode
{
	PM_FILL,
	PM_LINE,
	PM_POINT
};

enum CullMode
{
	CM_NONE,
	CM_FRONT,
	CM_BACK
};

enum FrontFace
{
	FF_COUNTER_CLOCKWISE,
	FF_CLOCKWISE
};

enum CompareFunc
{
	CF_NEVER,
	CF_LESS,
	CF_EQUAL,
	CF_LESS_OR_EQUAL,
	CF_GREATER,
	CF_NOT_EQUAL,
	CF_GREATER_OR_EQUAL,
	CF_ALWAYS,
};

enum BlendFactor
{
	BF_ZERO,
	BF_ONE,

	BF_SRC_ALPHA,
	BF_DST_ALPHA,

	BF_ONE_MINUS_SRC_ALPHA,
	BF_ONE_MINUS_DST_ALPHA
};

enum BlendOperator
{
	BO_ADD,
	BO_SUBTRACT
};

enum StencilOperator
{
	SO_KEEP,
	SO_ZERO,
	SO_REPLACE,
	SO_INC,
	SO_DEC
};

enum LoadOperation
{
	LO_LOAD,
	LO_DONT_CARE,
	LO_CLEAR
};

enum StoreOperation
{
	SO_STORE,
	SO_DONT_CARE
};

enum QueryType
{
	QT_OCCLUSION
};

enum QueryStatus
{
	QS_INVAILD,
	QS_IDEL,
	QS_QUERY_START,
	QS_QUERYING,
	QS_QUERY_END
};

enum PipelineStage
{
	PIPELINE_STAGE_TOP_OF_PIPE = 1 << 0,
	PIPELINE_STAGE_DRAW_INDIRECT = 1 << 1,
	PIPELINE_STAGE_VERTEX_INPUT = 1 << 2,
	PIPELINE_STAGE_VERTEX_SHADER = 1 << 3,
	PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER = 1 << 4,
	PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER = 1 << 5,
	PIPELINE_STAGE_GEOMETRY_SHADER = 1 << 6,
	PIPELINE_STAGE_FRAGMENT_SHADER = 1 << 7,
	PIPELINE_STAGE_EARLY_FRAGMENT_TESTS = 1 << 8,
	PIPELINE_STAGE_LATE_FRAGMENT_TESTS = 1 << 9,
	PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT = 1 << 10,
	PIPELINE_STAGE_COMPUTE_SHADER = 1 << 11,
	PIPELINE_STAGE_TRANSFER = 1 << 12,
	PIPELINE_STAGE_BOTTOM_OF_PIPE = 1 << 13,
	PIPELINE_STAGE_HOST = 1 << 14,

	PIPELINE_STAGE_ENDENUM
};
typedef unsigned int PipelineStages;

enum LayoutShader
{
	LAYOUT_SHADER_VERTEX,
	LAYOUT_SHADER_FRAGMENT,
	LAYOUT_SHADER_GEOMETRY,
	LAYOUT_SHADER_TASK,
	LAYOUT_SHADER_MESH,
	LAYOUT_SHADER_COUNT
};

enum QueueCategory
{
	QUEUE_GRAPHICS,
	QUEUE_COMPUTE,
	QUEUE_TRANSFER,
	QUEUE_PRESENT
};

enum CommandBufferLevel
{
	CBL_PRIMARY,
	CBL_SECONDARY
};

enum CommmandBufferReset
{
	CBR_RESET_POOL,
	CBR_RESET_INDIVIDUALLY,
	CBR_RESET_ALLOCATE_FREE
};

enum SubpassContents
{
	SUBPASS_CONTENTS_INLINE,
	SUBPASS_CONTENTS_SECONDARY
};

enum ImageLayout
{
	IMAGE_LAYOUT_GENERAL,
	IMAGE_LAYOUT_COLOR_ATTACHMENT,
	IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT,
	IMAGE_LAYOUT_TRANSFER_SRC,
	IMAGE_LAYOUT_TRANSFER_DST,
	IMAGE_LAYOUT_SHADER_READ_ONLY,
	IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY,
	IMAGE_LAYOUT_UNDEFINED
};

struct IKSwapChain;
typedef std::unique_ptr<IKSwapChain> IKSwapChainPtr;

struct IKRenderWindow;
typedef std::unique_ptr<IKRenderWindow> IKRenderWindowPtr;

struct IKRenderDevice;
typedef std::unique_ptr<IKRenderDevice> IKRenderDevicePtr;

struct IKUIOverlay;
typedef std::unique_ptr<IKUIOverlay> IKUIOverlayPtr;

struct IKShader;
typedef std::shared_ptr<IKShader> IKShaderPtr;

struct IKVertexBuffer;
typedef std::shared_ptr<IKVertexBuffer> IKVertexBufferPtr;

struct IKAccelerationStructure;
typedef std::shared_ptr<IKAccelerationStructure> IKAccelerationStructurePtr;

struct IKIndexBuffer;
typedef std::shared_ptr<IKIndexBuffer> IKIndexBufferPtr;

struct IKStorageBuffer;
typedef std::shared_ptr<IKStorageBuffer> IKStorageBufferPtr;

struct IKUniformBuffer;
typedef std::shared_ptr<IKUniformBuffer> IKUniformBufferPtr;

struct IKQuery;
typedef std::shared_ptr<IKQuery> IKQueryPtr;

struct IKTexture;
typedef std::shared_ptr<IKTexture> IKTexturePtr;

struct IKSampler;
typedef std::shared_ptr<IKSampler> IKSamplerPtr;

struct IKRenderTarget;
typedef std::shared_ptr<IKRenderTarget> IKRenderTargetPtr;

struct IKPipeline;
typedef std::shared_ptr<IKPipeline> IKPipelinePtr;

struct IKPipelineLayout;
typedef std::shared_ptr<IKPipelineLayout> IKPipelineLayoutPtr;

struct IKPipelineHandle;
typedef std::shared_ptr<IKPipelineHandle> IKPipelineHandlePtr;

struct IKRayTracePipeline;
typedef std::shared_ptr<IKRayTracePipeline> IKRayTracePipelinePtr;

struct IKComputePipeline;
typedef std::shared_ptr<IKComputePipeline> IKComputePipelinePtr;

struct IKCommandPool;
typedef std::shared_ptr<IKCommandPool> IKCommandPoolPtr;

struct IKCommandBuffer;
typedef std::shared_ptr<IKCommandBuffer> IKCommandBufferPtr;

struct IKFrameBuffer;
typedef std::shared_ptr<IKFrameBuffer> IKFrameBufferPtr;

struct IKRenderPass;
typedef std::shared_ptr<IKRenderPass> IKRenderPassPtr;

struct IKSemaphore;
typedef std::shared_ptr<IKSemaphore> IKSemaphorePtr;

struct IKFence;
typedef std::shared_ptr<IKFence> IKFencePtr;

struct IKQueue;
typedef std::shared_ptr<IKQueue> IKQueuePtr;